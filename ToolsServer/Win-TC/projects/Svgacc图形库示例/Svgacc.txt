






                                  REFERENCE MANUAL


                                     FOR SVGACC


                                    THE SUPER VGA


                                  GRAPHICS LIBRARY


                                    FOR USE WITH


                                      MICROSOFT


                                  COMPATIBLE C/C++


                                      COMPILERS























          1993-2000 by Zephyr Software - Stephen L. Balkum and Daniel A.
          Sill

          All rights reserved.  No part of this book shall be reproduced or
          transmitted by any means, electronic, mechanical, photocopying,
          recording or otherwise, without written permission from Zephyr
          Software - Stephen L. Balkum and Daniel A. Sill.

          Although every effort has been made to insure the accuracy of the
          material in this book, Zephyr Software, Stephen L. Balkum and
          Daniel A. Sill assume no responsibility for errors or omissions.
          In addition no liability is assumed for damages resulting from
          the use of the information contained herein.

          Printed in the United States of America

          Trademarks

          Sound Blaster and Sound Blaster Pro are trademarks of Creative
          Labs, Inc.
          All others are trademarks of their respective owners.



















                                                                         ii









                             SOFTWARE LICENSE AGREEMENT

               By using this software, you agree to the terms of this
                                     agreement.

               No warranties are expressed or implied.  In no event
               shall Zephyr Software, Stephen L. Balkum or Daniel A.
               Sill be held liable for damages resulting from the use
               or misuse of this product, including but not limited to
               implied warranties of fitness for a particular purpose.

               The shareware version may be freely distributed as long
               as all files stay together and are not modified in any
               way.  No cost may be charged for the shareware version
               beyond normal and reasonable copying and distribution
               expenses.

               No products developed with this software shall be sold
               unless this software has been registered with Zephyr
               Software, Stephen L. Balkum or Daniel A. Sill.

               At no time for any reason shall this software be
               reverse engineered, decompiled or disassembled.

               This software may not be rented or leased.

               This software may be used only on one terminal or one
               computer at any one given moment in time.  This
               software may not be installed on a network of any type.
               Contact Zephyr Software, Stephen L. Balkum or Daniel A.
               Sill for networking options.

               United States Government Restricted Rights:
               Use, duplication or disclosure of this software and
               documentation by the U.S. Government is subject to the
               restrictions as set forth in subparagraph (c)(1)(ii) of
               the Rights in Technical Data and Computer Software
               clause at DFARS 252.227-7013.  Contractor/manufacturer
               is Stephen L. Balkum and Daniel A. Sill, P.O. Box 407,
               Pflugerville, Texas 78619-0407.

               The ownership of this software may be transferred as
               long as Zephyr Software, Stephen L. Balkum or Daniel A.
               Sill is notified in writing of the transfer date and
               new owner.  The new owner must agree to this contract.
               The transfer must include all registered updates and
               previously registered versions.  The original owner may
               not retain any copies in any form of the registered
               software or its documents.





                                                                        iii







          INTRODUCTION

          We spent weeks searching the depths of the internet ftp sites for
          a library that would allow the programmer full access to the
          abilities of Super VGA.  We wanted the colors VGA could provide
          and better resolution than EGA could provide.  Professionally
          developed libraries with this ability were definitely out of our
          price range.  After our searches continuously returned nothing,
          we decided to fill the apparent void in the shareware market.

          Our searches did give two useful packages:  John Bridges' VGAKIT
          and Finn Thoegersen's VGADOC.  We began with these two works and
          developed a graphics library intended to allow the programmer
          access to the huge world of high resolution programming.

          On the surface the task appeared quite simple.  However, it
          quickly became obvious that the routines in this library would be
          required to affect extremely large amounts of data.  Operations
          must be quick to be successful.  Therefore, every effort was made
          to create the fastest code possible - even at the expense of
          size.  For this reason we opted to write code with the 32 bit
          instructions of the 80386 and better processors.  It is our
          opinion that anyone with a hi-res card in a lesser machine may
          have some priorities out of order.  All routines are written in
          assembly and use absolutely no floating point values.  Anytime a
          real number was required, fixed point notation was used.  In
          addition we attempted to write the routines such that any
          reasonable argument passed can be interpreted intelligently by
          the library.

          With the numerous Super VGA cards available and no well
          established standard we chose John Bridges' identification and
          bank switching routines as a beginning.  These two routines have
          undergone some modification, but not enough to justify
          copyrighting this portion of the library's code by Zephyr
          Software.  We have no intentions of releasing our changes to
          these routines into the public domain.  From that point onward
          all code is original.  In some instances common algorithms were
          researched and original code written according to that algorithm.

          This Super VGA library gives the programmer transparent access to
          twenty different Super VGA cards.  These cards include Acumos,
          Ahead, ATI Technologies, Avance, Chips and Technologies, Cirrus
          Logic, Everex, Genoa, MXIC, NCR, Oak Technologies,
          Paradise/Western Digital, Primus, Realtek, Trident, Tseng Labs,
          Video 7 and the VESA standard.  Please see the WHICHVGA function
          for the specific chipsets.  The programmer only needs to verify
          that the end user's card has been identified, but not which card
          was recognized.  After proper identification, all functions react
          in exactly the same fashion.  The library contains functions to
          draw all of the major primitives.  In addition there are
          functions that modify the screen palette, write text on the
          screen with a choice of fonts and modify the reaction of the
          primitives.  Identification routines include not only the video


                                                                          2







          card, but also the amount of video memory, type of processor and
          installed pointing devices.  Advanced functions provide full
          mouse support (when used with a Microsoft compatible driver) and
          joystick support.  Finally, support for two dimensional and three
          dimensional coordinate systems is provided including rotation,
          translation, scaling and projection.


















































                                                                          3







          SUGGESTED METHODS FOR USING THIS LIBRARY

          VERIFICATION OF A COMPUTER'S HARDWARE

          It is strongly recommended that any program written with this
          library first verifies that the computer is a 80386 or better by
          calling the WHICHCPU function.  Many of the library's functions
          use 386 exclusive code which may cause a computer with a lesser
          processor to crash.  In addition WHICHMOUSE must be called before
          calling any of the mouse functions.  Lastly, it is recommended
          that WHICHJOYSTICK be called before a program uses the joystick
          routines.

          It is required that a program call WHICHVGA prior to any function
          that communicates with the video card.  If WHICHVGA returns a
          zero for unknown card type, the program should not call any
          graphics function.  Without proper identification of the video
          card any graphics function will likely cause a system failure.
          It is recommended, although not necessary, that a program call
          WHICHMEM prior to calling any RES function.  Although the video
          card was properly identified, it may not have sufficient onboard
          memory to support the desired resolution.  As a second check the
          RES functions will do nothing if the video card has not been
          identified or if the video card does not support the specified
          resolution for memory or hardware reasons.

          THE 256 COLOR PALETTE

          The 256 color palette of the Super VGA cards is a six bit
          palette.  Each of the 256 colors of the palette are described by
          three values representing the intensity of the colors red, blue
          and green.  These values can range from 0 to 63.  Anytime a value
          outside of this range is used, the video card simply ignores the
          upper two bits.  Therefore, 64 is the same as 0.  This should be
          taken into consideration when manipulating the palette or when
          importing a palette from an external source such as a PCX image.

          USE OF 2-D AND 3-D FUNCTIONS

          In the interest of speed, the 2-D and 3-D functions were written
          to best work on multiple points at once.  We refer to these
          functions as object-oriented.  This means that the points
          defining an object (a box, a house, etc.) should be contained
          within one array or part of an array and calls to the functions
          should act on all of the points in the array.  Calls to functions
          have a high speed overhead, therefore, placing more than one
          object in the same array and passing the entire array to the
          functions can be beneficial.  However, these functions will work
          on a single point as well.

          A consequence of our object-oriented 2-D and 3-D functions is the
          use of the scaling functions.  When scaling objects, we recommend
          the object be defined about the origin.  D2SCALE and D3SCALE both
          work with respect to the origin.  This eliminates a significant


                                                                          4







          number of translations that would otherwise be required by having
          a definable scale origin.  For example, to draw two boxes, one
          scaled by one-half of the other, each rotated by 45 degrees at
          the center of the screen, the recommended procedure is as
          follows:

            define an array BOX containing the 2-D points: (100, 100), (-
               100, 100), (-100, -100), (100, -100), (note: the box is
               centered about the origin.)
            rotate BOX by 45 degrees about (0, 0) and place the output in
               RBOX,
            scale RBOX by 50% (scaling factor would be 128, or 80 hex) and
               place output in SRBOX,
            translate RBOX to the center of the screen - a translation of
               320, 240 in 640x480 resolution - and place output in TRBOX,
            translate SRBOX to the center of the screen - same translation
               as for RBOX - and place output in TSRBOX,
            draw TRBOX and TSRBOX on the screen.

          Notice that by defining the box centered about the origin the
          translation values were extremely intuitive.  Also notice that if
          we had scaled the second box after the translation, it would have
          been draw in the upper left quadrant of the screen instead of the
          center.

          In mathematics and many sciences it is customary that in a 2-D
          coordinate system the Y axis increases upward and the X axis
          increases to the right.  The computer industry has decided the Y
          axis should increase downward.  The 2-D functions are not
          affected by the choice in coordinate systems.  However, it is
          important to remember that a positive rotation in D2ROTATE
          rotates from the positive X axis to the positive Y axis.
          Therefore, when using mathematical conventions, a positive
          rotation moves counter-clockwise.  On the computer screen a
          positive rotation moves clockwise.

          The 3-D coordinate system follows mathematical conventions by
          using a right-handed coordinate system.  The easiest way to
          visualize this coordinate system is by using your right hand.
          Place your index finger and thumb at a right angle to one another
          as if to form an imaginary pistol.  Now place your second finger
          at a right angle to your index finger.  It should be at a right
          angle to your thumb as well.  This represents the three axes.
          The index finger is the X axis, the second finger is the Y axis
          and the thumb is the Z axis.  The easiest way to remember
          rotation directions in this system is cyclically.  A positive
          rotation about the X axis rotates the Y axis into the Z axis.  A
          positive rotation about the Y axis rotates the Z axis into the X
          axis.  A positive rotation about the Z axis rotates the X axis
          into the Y axis.

          After doing all necessary 3-D transformations, projection onto
          the 2-D computer screen is required.  Although the computer
          screen's coordinate system does not follow mathematical


                                                                          5







          conventions, the D3PROJECT function automatically takes care of
          all conversions.  The programmer only needs to draw the resulting
          object on the screen with FILLCONVEXPOLY, FILLPOLY or a series of
          DRWLINEs.

          THE CONCEPT OF SPRITE GRAPHICS

          The key to sprite graphics is the assumption that only a small
          percentage of the pixels in a graphics block are used by the
          animation and the remaining pixels should be treated as
          transparent, revealing the background behind the sprite.  The
          sprite routines in this library only act on non-transparent
          colors, thus, saving time by ignoring a large number of pixels.
          When retrieving the background for a sprite, prior knowledge of
          the sprite itself permits obtaining background only where it is
          necessary.

          The following steps outline an example of the recommended
          procedure for using the sprite functions:

            1. draw the sprite on the screen - a white stick figure on a
               black background, for example
            2. use BLKGET to place the sprite in an array STICK
            3. use SPRITEGAP to simultaneously retrieve the background into
               BACKSTICK and place STICK on the screen, declaring black as
               the transparent color
            4. use SPRITEPUT to replace the background BACKSTICK in the
               same location as step 3
            5. repeat steps 3 and 4 as many times and in as many locations
               as desired

          GLOBAL VARIABLES

          Access to several global variables provided to the programmer.
          The most important two variables are MAXX and MAXY.  These two
          values give the current resolution and are set by the RES###
          functions.  They should not be changed directly at any time by
          the programmer.  Doing so may cause erratic results from many of
          the graphics functions in this library.  These variables
          initially contain 0.

          Four other variables, VIEWX1, VIEWY1, VIEWX2, VIEWY2, can be
          accessed by the programmer.  They define the current viewport
          used for clipping purposes.  These values, also, should not be
          changed directly by the programmer.  The SETVIEW function should
          be used to change these values as it performs important error
          checking.  The viewport is defined as the whole screen by the
          RES### functions.  If drawing on more or less than the entire
          screen is desired, call SETVIEW as necessary.

          EXTENDED MEMORY SUPPORT

          With the higher screen resolutions, more memory may be needed for
          data storage.  For this reason extended memory support is


                                                                          6







          provided.  Accessing extended memory requires the computer to
          switch into protected mode.  The process of switching into
          protected mode and returning is handled by the extended memory
          manager, usually HIMEM.SYS.  The switch is relatively slow.
          Therefore, it should be used as fast storage access since it is
          much faster than disk access.

          Extended memory access is also limited by the number of available
          handles.  The limit is controlled by a switch on the extended
          memory manager's command line and normally defaults to 32.  Also,
          it is imperative that all allocated extended memory blocks be
          freed before the program terminates.  Unfreed memory blocks will
          be unavailable until the computer is rebooted.

          CONVENTIONS USED IN THIS MANUAL

          All parameters, other than pointers, passed to and from functions
          and procedures in this graphics library are short (two byte)
          integers  A byte variable type is assumed to be an unsigned
          character.  No floating point values are used.  By not using real
          numbers round-off error can be a concern.  Under most
          circumstances this error will not be a problem and will not be
          noticed.  The use of large numbers in rotations is recommended.

          No functions in this library allocate memory for the programmer,
          except, of course, XMSALLOCATE.  It is the programmer's
          responsibility to be sure all pointers reference properly
          allocated memory of the appropriate size.

          Whenever a pixel is written on the screen, a mode is required.
          Unless otherwise noted, there are five possible modes:
          NO_ACTION, SET, XOR, OR and AND.  These modes are represented by
          the numbers zero through four respectively.  NO_ACTION is self-
          explanatory.  Technically, SET is the fastest mode.  However, XOR
          maybe the most useful.  XOR'ing a point twice with the same color
          returns the original color.  This can be used to cover and
          uncover graphics.  In addition when a reference to a color index
          is made, only values between and including 0 and 255 are valid.
          Any integer will work, but only the lowest eight bits are
          recognized.
















                                                                          7







          BLKGET

            PROTOTYPE

            extern int far blkget (int x1, int y1, int x2, int y2,
            RasterBlock far *gfxblk)

            INPUT

            x1, y1 - top left corner of block
            x2, y2 - bottom right corner of block

            OUTPUT

            BLKGET returns 1 if successful, 0 if failed.
            gfxblk - retrieved bitmap

            USAGE

            BLKGET stores the pixel data contained within the block
            defined by (x1, y1)-(x2, y2) in the variable referenced by
            gfxblk.  Memory for gfxblk must be allocated as a RasterBlock
            structure with a data size in bytes equal to

                                 [(x2-x1+1)*(y2-y1+1)]

            plus four bytes for the width and height integers of the
            RasterBlock structure.

            Note, however, that gfxblk can be quite large.  If the size of
            gfxblk is insufficient, BLKGET will overwrite any data in
            memory contained beyond gfxblk and may possibly cause the
            system to crash.  In addition the segmented nature of real
            mode programming requires that gfxblk be smaller 65536 bytes.
            For larger blocks, see XMSBLKGET.  BLKGET enforces X2 X1 and
            Y2 Y1.  Also, the coordinates must be valid on the screen at
            the current resolution.

            SEE ALSO

            BLKPUT, BLKRESIZE, BLKROTATE, GETLASTSTRING, SPRITEGAP,
            SPRITEGET, SPRITEPUT, XMSBLKGET, XMSBLKPUT

            EXAMPLE

            /*
             * Places 1/4 of a circle at the center of the screen
             */
            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {


                                                                          8







               int vmode;
               int a,b,c,d;
               RasterBlock *blkdata;

               vmode = videomodeget();
               if ( !whichvga() || (whichmem() < 512))
                 exit(1);
               res640();
               drwcircle(1,10,30,30,20);
               fillarea(30,30,10,7);
               a = b = 0;
               c = d = 30;
               blkdata = (RasterBlock *)malloc((c-a+1)*(d-b+1)+4);
               blkget(a,b,c,d,blkdata);
               blkput(1,320,240,blkdata);
               getch();
               videomodeset(vmode);
               exit(0);
            }





































                                                                          9







          BLKPUT

            PROTOTYPE

            extern void far blkput (PixelMode mode, int x, int y,
            RasterBlock far *gfxblk)

            INPUT

            mode - pixel write mode
            x, y - location for top left corner of block
            gfxblk - RasterBlock pointer to bitmap

            OUTPUT

            no value returned

            USAGE

            BLKPUT places the pixel data contained in the variable
            referenced by gfxblk on the screen.  The top, left corner of
            the block is specified by (X, Y).  Any (X, Y) is acceptable
            and any portion of the block that lies outside of the
            currently defined viewport will not be drawn.

            SEE ALSO

            BLKGET, BLKRESIZE, BLKROTATE, GETLASTSTRING, SPRITEGAP,
            SPRITEGET, SPRITEPUT, PCXPUT, SETVIEW, XMSBLKGET, XMSBLKPUT

            EXAMPLE

            See BLKGET























                                                                         10







          BLKRESIZE

            PROTOTYPE

            extern void far blkresize (unsigned newxsize, unsigned
               newysize, RasterBlock far *sourcegfxblk, RasterBlock far
               *destgfxblk)

            INPUT

            newxsize, newysize - size of resulting bitmap in destgfxblk
            sourcegfxblk - RasterBlock pointer to source bitmap

            OUTPUT

            no value returned
            destgfxblk - resized bitmap

            USAGE

            BLKRESIZE takes the bitmap in sourcegfxblk and scales it up or
            down according the to values passed in newxsize and newysize.
            The resulting bitmap is returned in destgfxblk which should
            already be declared with a size calculated according to the
            equation in BLKGET.  Neither newxsize nor newysize should be
            zero.

            SEE ALSO

            BLKGET, BLKPUT, BLKROTATE

            EXAMPLE

            /*
             * Show blkresize
             */
            #include <stdlib.h>
            #include <math.h>
            #include <conio.h>
            #include "svgacc.h"
            #define randnum(size) (rand() % (int)(size))

            void main(void)
            {
               int vmode, i, j, colr, x1, y1, x2, y2;
               RasterBlock *gfxblk1, *gfxblk2;

               vmode = videomodeget();
               if ( !whichvga() || (whichmem() < 512))
                 exit(1);
               if ( !res640() )
                 exit(1);
               i=20000;
               gfxblk1 = (RasterBlock *)malloc(i);


                                                                         11







               if (!gfxblk1) {
                 restext();
                 printf("ERROR: Allocating memory for gfxblk1: %d
            bytes\n",i);
                 exit(1);
               }
               gfxblk2 = (RasterBlock *)malloc(i);
               if (!gfxblk2) {
                 restext();
                 printf("ERROR: Allocating memory for gfxblk2: %d
            bytes\n",i);
                 exit(1);
               }
               for(i=0;i<=25;i++) {
                 x1 = randnum(50);
                 y1 = randnum(50);
                 x2 = randnum(50);
                 y2 = randnum(50);
                 colr = randnum(16);
                 drwline(1,colr,x1,y1,x2,y2);
               }
               x1 = 0;
               y1 = 0;
               x2 = 50;
               y2 = 50;
               drwbox(1,15,x1,y1,x2,y2);
               blkget(x1,y1,x2,y2,gfxblk1);
               x1 = maxx / 2;
               y1 = maxy / 2;
               blkresize(50,50,gfxblk1,gfxblk2);
               blkput(2,x1-(gfxblk2->width)/2,y1-(gfxblk2-
            >height)/2,gfxblk2);
               for(i=x2;i<=x2+50;i++) {
                 blkput(2,x1-(gfxblk2->width)/2,y1-(gfxblk2-
            >height)/2,gfxblk2);
                 blkresize(i,i,gfxblk1,gfxblk2);
                 blkput(2,x1-(gfxblk2->width)/2,y1-(gfxblk2-
            >height)/2,gfxblk2);
                 sdelay(3);
               }
               for(i=x2+50;i>=x2-50;i--) {
                 blkput(2,x1-(gfxblk2->width)/2,y1-(gfxblk2-
            >height)/2,gfxblk2);
                 blkresize(i,i,gfxblk1,gfxblk2);
                 blkput(2,x1-(gfxblk2->width)/2,y1-(gfxblk2-
            >height)/2,gfxblk2);
                 sdelay(3);
               }
               for(i=x2-50;i<=x2+1;i++) {
                 blkput(2,x1-(gfxblk2->width)/2,y1-(gfxblk2-
            >height)/2,gfxblk2);
                 blkresize(i,i,gfxblk1,gfxblk2);
                 blkput(2,x1-(gfxblk2->width)/2,y1-(gfxblk2-
            >height)/2,gfxblk2);


                                                                         12







                 sdelay(3);
               }
               getch();
               videomodeset(vmode);
               exit(0);
            }


















































                                                                         13







          BLKROTATE

            PROTOTYPE

            extern int  far blkrotate (int ang, int backfill, RasterBlock
            far *sourcegfxblk, RasterBlock far *destgfxblk)

            INPUT

            ang - integer degree to rotate source bitmap
            backfill - index to color in current palette to fill blank
            space in destgfxblk
            sourcegfxblk - RasterBlock pointer to source bitmap

            OUTPUT

            BLKROTATE returns 1 if successful, 0 if unsuccessful.
            destgfxblk - rotated bitmap

            USAGE

            BLKROTATE takes the bitmap in sourcegfxblk and rotates by the
            number of degrees specified in ang.  The bitmap rotation
            algorithm is a three-pass shear technique modified to make
            efficient use of this library's internal buffers.  Blank space
            around the newly rotated block is filled with the color given
            by backfill.  The resulting bitmap is stored in destgfxblk.
            The size of destgfxblk should be at least as big as given by
            BLKROTATESIZE.

            The function will fail if it calculates that the internal
            buffers would be overflowed or if the destination array would
            be larger than 65536 bytes.  BLKROTATESIZE should be called
            first to ensure that buffer integrity is maintained.

            SEE ALSO

            BLKGET, BLKPUT, BLKRESIZE, BLKROTATESIZE

            EXAMPLE

            /*
             * Show blkrotate
             */
            #include <stdlib.h>
            #include <math.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int xinc, yinc, x1, y1, x2, y2, i, j, colr, vmode, cntx,
            cnty, rot;
               RasterBlock *gfxblk, *gfxblk2, *spritebkgnd;


                                                                         14








               vmode = videomodeget();
               if ( !whichvga() || (whichmem() < 512))
                 exit(1);
               if ( !res640() )
                 exit(1);
               xinc = maxx/10;
               yinc = maxy/20;
               x1 = maxx/2-xinc;
               y1 = maxy/2-yinc;
               x2 = maxx/2+xinc;
               y2 = maxy/2+yinc;
               i = (x2-x1+1)*(y2-y1+1)+4;
               gfxblk = (RasterBlock *)malloc(i);
               if (!gfxblk) {
                 restext();
                 printf("ERROR: Allocating memory for gfxblk: %d
            bytes\n",i);
                 exit(1);
               }
               colr = 1;
               for(i=0;i<=maxx/2;i++) {
                 drwcircle(1,colr,maxx/4+i,maxy/2,maxy/5);
                 colr+=1;
                 if(colr>15)
                    colr = 1;
               }
               drwbox(1,0,x1,y1,x2,y2);
               blkget(x1,y1,x2,y2,gfxblk);
               cntx = (x2-x1) / 2 + x1;
               cnty = (y2-y1) / 2 + y1;
               fillarea(x1+2,y1+2,0,0);
               i = blkrotatesize(45,gfxblk);
               if ( !i ) {
                 restext();
                 printf("ERROR: rotated sprite will be to large");
                 exit(1);
               }
               spritebkgnd = (RasterBlock *)malloc(i);
               if (!spritebkgnd) {
                 restext();
                 printf("ERROR: Allocating memory for spritebkgnd: %d
            bytes\n",i);
                 exit(1);
               }
               gfxblk2 = (RasterBlock *)malloc(i);
               if (!gfxblk2) {
                 restext();
                 printf("ERROR: Allocating memory for gfxblk2: %d
            bytes\n",i);
                 exit(1);
               }
               blkget(x1,y1,x2,y2,spritebkgnd);
               setview(0,64,maxx,maxy);


                                                                         15







               for(i=0;i<=360;i+=3) {
                 rot = blkrotate(i,1,gfxblk,gfxblk2);
                 spriteput(SET,1,cntx-(spritebkgnd->width)/2,cnty-
            (spritebkgnd->height)/2,spritebkgnd);
                 spritegap(1,cntx-(gfxblk2->width)/2,cnty-(gfxblk2-
            >height)/2,gfxblk2,spritebkgnd);
                 sdelay(3);
               }
               spriteput(SET,1,cntx-(spritebkgnd->width)/2,cnty-
            (spritebkgnd->height)/2,spritebkgnd);
               blkput(SET,x1,y1,(RasterBlock *)gfxblk);
               videomodeset(vmode);
               exit(0);
            }










































                                                                         16







          BLKROTATESIZE

            PROTOTYPE

            extern int  far blkrotatesize (int ang, RasterBlock far
            *sourcegfxblk)

            INPUT

            ang - integer degree to rotate source bitmap
            sourcegfxblk - RasterBlock pointer to source bitmap

            OUTPUT

            BLKROTATESIZE returns the number of bytes needed for the
            destination array if successful, 0 if unsuccessful.

            USAGE

            BLKROTATESIZE takes the bitmap in sourcegfxblk and calculates
            the required size of the output buffer needed when BLKROTATE
            is called.  It also insures that the internal library buffers
            are not overflowed.  The function will fail if it calculates
            that the internal buffers would be overflowed or if the
            destination buffer would be larger than 65536 bytes.
            BLKROTATESIZE should be called prior to BLKROTATE to insure
            that buffer integrity is maintained.

            SEE ALSO

            BLKGET, BLKPUT, BLKRESIZE, BLKROTATE

            EXAMPLE

            See BLKROTATE





















                                                                         17







          BYTECOPY

            PROTOTYPE

            extern void far bytecopy (void far *src, void far *dst, long
            numbytes)

            INPUT

            src - pointer to array to be copied
            numbytes - number of bytes to copy from src (<65536)

            OUTPUT

            no value returned
            dst - copy of array

            USAGE

            BYTECOPY copies the specified number of bytes from src to dst.
            It assumes that space for dst has been properly allocated.  It
            is much faster than using a FOR loop or MEMCPY.

            SEE ALSO

            PALCOPY

            EXAMPLE

            /*
             * show byte copy
             */
            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int i;
               int test1[10], test2[10];

               for(i=0;i<10;i++)
               {
                 test1[i] = i;
               }
               bytecopy(test1,test2,sizeof(test1));
               printf("ok...we initialized one array with data, copied
            that\n");
               printf("array to an a new array...here are the results:\n");
               printf(" \n");
               printf("source array         destination array\n");
               for(i=0;i<10;i++)
               {
                 printf(" %d                    %d\n",test1[i],test2[i]);


                                                                         18







               }
               exit(0);
            }





















































                                                                         19







          D2ROTATE

            PROTOTYPE

            extern void far d2rotate (int points, int xorigin, int
            yorigin, int ang, D2Point far *inary, D2Point far *outary)

            INPUT

            numpoints - number of points to be rotated
            xorigin, yorigin - center of rotation
            angle - angle of rotation about center
            inary - D2Point pointer to array containing points to rotate

            OUTPUT

            no value returned
            outary - D2Point array of rotated values

            USAGE

            D2ROTATE takes the two dimensional points given in inary and
            rotates them by the specified angle about xorigin, yorigin.
            The results are returned in outary which can be the same as
            inary.  A positive angle causes a clockwise rotation on the
            screen, from the positive X axis to the positive Y axis.  The
            function assumes space for outary has been properly allocated.

            SEE ALSO

            D2SCALE, D2TRANSLATE

            EXAMPLE

            /*
             * shows d2rotate works
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            D2Point tri[3];
            D2Point trio[3];
            D2Point tri2[3];

            void drwtri(void);
            void ertri(void);

            void main(void)
            {
               int vmode,i;

               vmode = videomodeget();


                                                                         20







               if (!whichvga())
                 exit(1);
               if (whichmem()<512)
                 exit(1);
               res640();
               trio[0].x = 0;
               trio[0].y = 0;
               trio[1].x = -80;
               trio[1].y = 60;
               trio[2].x = 80;
               trio[2].y = 60;
               drwtri();
               for(i=0;i<=360;i+=2)
               {
                 d2rotate(3,0,0,i,trio,tri);
                 drwtri();
                 sdelay(2);
                 ertri();
               }
               drwtri();
               getch();
               videomodeset(vmode);
               exit(0);
            }

            void drwtri(void)
            {
               d2translate(3,320,240,tri,tri2);
               drwline(1,10,tri2[0].x,tri2[0].y,tri2[1].x,tri2[1].y);
               drwline(1,10,tri2[1].x,tri2[1].y,tri2[2].x,tri2[2].y);
               drwline(1,10,tri2[2].x,tri2[2].y,tri2[0].x,tri2[0].y);
               return;
            }

            void ertri(void)
            {
               d2translate(3,320,240,tri,tri2);
               drwline(1,0,tri2[0].x,tri2[0].y,tri2[1].x,tri2[1].y);
               drwline(1,0,tri2[1].x,tri2[1].y,tri2[2].x,tri2[2].y);
               drwline(1,0,tri2[2].x,tri2[2].y,tri2[0].x,tri2[0].y);
               return;
            }














                                                                         21







          D2SCALE

            PROTOTYPE

            extern void far d2scale (int points, int scalex, int scaley,
            D2Point far *inary, D2Point far *outary)

            INPUT

            numpoints - number of points to scale
            scalex - scale factor along X axis
            scaley - scale factor along Y axis
            inary - D2Point pointer to array containing points to scale

            OUTPUT

            no value returned
            outary - D2Point array of scaled values

            USAGE

            D2SCALE multiplies each coordinate in the two dimensional
            array inary by the corresponding scale factor scalex or
            scaley.  The results are stored in outary which can be the
            same as inary.  A scale factor of 256 (100 hex) is considered
            100 percent and results in no change.  Therefore, 128 (80 hex)
            reduces values by one half and 512 (200 hex) doubles values.
            The function assumes space for outary has been properly
            allocated.

            SEE ALSO

            D2ROTATE, D2TRANSLATE

            EXAMPLE

            /*
             * shows d2scale works
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            D2Point tri[3];
            D2Point trio[3];
            D2Point tri2[3];

            void drwtri(void);
            void ertri(void);

            void main(void)
            {
               int vmode,i;


                                                                         22








               vmode = videomodeget();
               if (!whichvga())
                 exit(1);
               if (whichmem()<512)
                 exit(1);
               res640();
               trio[0].x = 0;
               trio[0].y = 0;
               trio[1].x = -80;
               trio[1].y = 60;
               trio[2].x = 80;
               trio[2].y = 60;
               drwtri();
               for(i=256;i<=512;i+=4)
               {
                 d2scale(3,i,i,trio,tri);
                 drwtri();
                 sdelay(2);
                 ertri();
               }
               for(i=512;i>=128;i-=4)
               {
                 d2scale(3,i,i,trio,tri);
                 drwtri();
                 sdelay(2);
                 ertri();
               }
               for(i=128;i<=256;i+=4)
               {
                 d2scale(3,i,i,trio,tri);
                 drwtri();
                 sdelay(2);
                 ertri();
               }
               drwtri();
               getch();
               videomodeset(vmode);
               exit(0);
            }

            void drwtri(void)
            {
               d2translate(3,320,240,tri,tri2);
               drwline(1,10,tri2[0].x,tri2[0].y,tri2[1].x,tri2[1].y);
               drwline(1,10,tri2[1].x,tri2[1].y,tri2[2].x,tri2[2].y);
               drwline(1,10,tri2[2].x,tri2[2].y,tri2[0].x,tri2[0].y);
               return;
            }

            void ertri(void)
            {
               d2translate(3,320,240,tri,tri2);
               drwline(1,0,tri2[0].x,tri2[0].y,tri2[1].x,tri2[1].y);


                                                                         23







               drwline(1,0,tri2[1].x,tri2[1].y,tri2[2].x,tri2[2].y);
               drwline(1,0,tri2[2].x,tri2[2].y,tri2[0].x,tri2[0].y);
               return;
            }




















































                                                                         24







          D2TRANSLATE

            PROTOTYPE

            extern void far d2translate (int points, int xtrans, int
            ytrans, D2Point far *inary, D2Point far *outary)

            INPUT

            numpoints - number of points to be translated
            xtrans - distance to translate along X axis
            ytrans - distance to translate along Y axis
            inary - D2Point pointer to array containing points to
            translate

            OUTPUT

            no value returned
            outary - D2Point array of translated values

            USAGE

            D2TRANSLATE takes the two dimensional points given in inary
            and translates them by the specified number of pixels along
            each axis.  The results are returned in outary which can be
            the same as inary.  The function assumes that space for outary
            has been properly allocated.

            SEE ALSO

            D2ROTATE, D2SCALE

            EXAMPLE

            /*
             * shows d2translate works
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            D2Point tri[3];
            D2Point trio[3];
            D2Point tri2[3];

            void drwtri(void);
            void ertri(void);

            void main(void)
            {
               int vmode,i;

               vmode = videomodeget();


                                                                         25







               if (!whichvga())
                 exit(1);
               if (whichmem()<512)
                 exit(1);
               res640();
               trio[0].x = 0;
               trio[0].y = 0;
               trio[1].x = -80;
               trio[1].y = 60;
               trio[2].x = 80;
               trio[2].y = 60;
               drwtri();
               for(i=0;i<=100;i+=4)
               {
                 d2translate(3,i,i,trio,tri);
                 drwtri();
                 sdelay(2);
                 ertri();
               }
               for(i=100;i>=0;i-=4)
               {
                 d2translate(3,i,i,trio,tri);
                 drwtri();
                 sdelay(2);
                 ertri();
               }
               drwtri();
               getch();
               videomodeset(vmode);
               exit(0);
            }

            void drwtri(void)
            {
               d2translate(3,320,240,tri,tri2);
               drwline(1,10,tri2[0].x,tri2[0].y,tri2[1].x,tri2[1].y);
               drwline(1,10,tri2[1].x,tri2[1].y,tri2[2].x,tri2[2].y);
               drwline(1,10,tri2[2].x,tri2[2].y,tri2[0].x,tri2[0].y);
               return;
            }

            void ertri(void)
            {
               d2translate(3,320,240,tri,tri2);
               drwline(1,0,tri2[0].x,tri2[0].y,tri2[1].x,tri2[1].y);
               drwline(1,0,tri2[1].x,tri2[1].y,tri2[2].x,tri2[2].y);
               drwline(1,0,tri2[2].x,tri2[2].y,tri2[0].x,tri2[0].y);
               return;
            }







                                                                         26







          D3PROJECT

            PROTOTYPE

            extern int far d3project (int points, ProjParameters far
            *params, D3Point far *inary, D2Point far *outary)

            INPUT

            numpoints - number of points to be projected
            params - pointer to ProjParameters structure containing
            parameters used in projection
               eyex, eyey, eyez - 3D location of viewer
               scrd - distance from viewer to projection screen
               theta - angle from positive 3D X axis to viewing direction
               phi - angle from positive 3D Z axis to viewing direction
            inary - D3Point pointer to array containing points to project

            OUTPUT

            Returns 1 if successful, 0 if any one point failed.
            outary - D2Point array of projected values

            USAGE
                                +Z axis
                                   |                   /\
                                   |                  /  \
                                   |            !     \ * \
                                   |            !......X: /
                                   |            ! Phi / \/
                                   |            !    /  :
                                   |            !   /   :
                                   |            !  /    :
                                   |       EyeX ! /ScrD :
                                   |       EyeY !/      :
                                   |       EyeZ *- - - -:- - - - -
                                   |           / `      :
                                   |          /   `     :
                                   |         /      `   :
                                   |        /      ---` :
                                   |       /___----
                                   |      /     Theta
                                   |
                                   |_____________________________+Y axis
                                   /
                                  /
                                 /
                                /
                               /
                              /
                             /
                         +X axis




                                                                         27







            D3PROJECT projects a specified number, numpoints, of three
            dimensional points starting at inary into two dimensions
            according to the parameters in params.  The two dimensional
            points are stored in outary.  The function assumes space for
            outary has been properly allocated.  The location of the
            viewer in this three dimensional space is given by eyex, eyey,
            eyez in the ProjParameters structure.  The direction the
            viewer is facing is specified with scrd, theta, phi in the
            ProjParameters structure using spherical coordinates.  A
            virtual set of axes parallel to the true axes are placed at
            the viewer's location.  scrd is the distance from the viewer
            to the center of the projection screen, i.e. the currently
            defined viewport on the monitor's screen.  Theta is the angle
            in the virtual X-Y plane from the virtual X axis to the
            projection screen.  Positive angles rotate counter-clockwise
            in the X-Y plane.  Lastly, the angle of elevation above or
            below the virtual X-Y plane is given by phi.  Positive angles
            direct viewing above the plane; negative below.

            If a point is projected to a location behind the viewer, i.e.
            on the side of the viewer opposite the projection screen,
            D3PROJECT returns a zero indicating one or more failed points.
            The returned values of the X and Y for failed points will be -
            32768 to make them easily identified.

            SEE ALSO

            D3ROTATE, D3TRANSLATE, D3SCALE, FILLCONVEXPOLY, SETVIEW

            EXAMPLE

            /* shows d3project works */
            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            D2Point plot[8];
            void drwcube(void);

            void main(void)
            {
               int vmode,i,dummy;
               ProjParameters proj;
               D3Point cube[8] = { { 100,-100, 100},
                                { 100,-100,-100},
                                { 100, 100,-100},
                                { 100, 100, 100},
                                {-100,-100, 100},
                                {-100,-100,-100},
                                {-100, 100,-100},
                                {-100, 100, 100}};

               vmode = videomodeget();
               if (!whichvga())


                                                                         28







                 exit(1);
               if (whichmem()<512)
                 exit(1);
               res640();
               proj.eyex = -1040;
               proj.eyey = -600;
               proj.eyez = -1200;
               proj.scrd = 1700;
               proj.theta = 30;
               proj.phi = 45;
               dummy = d3project(8,&proj,cube,plot);
               drwcube();
               getch();
               videomodeset(vmode);
            }

            void drwcube(void)
            {
               int i;

               for(i=0;i<=2;i++)

               drwline(1,10,plot[i].x,plot[i].y,plot[i+1].x,plot[i+1].y);
               drwline(1,10,plot[3].x,plot[3].y,plot[0].x,plot[0].y);
               for(i=4;i<=6;i++)

               drwline(1,10,plot[i].x,plot[i].y,plot[i+1].x,plot[i+1].y);
               drwline(1,10,plot[7].x,plot[7].y,plot[4].x,plot[4].y);
               for(i=0;i<=3;i++)

               drwline(1,10,plot[i].x,plot[i].y,plot[i+4].x,plot[i+4].y);
               return;
            }























                                                                         29







          D3ROTATE

            PROTOTYPE

            extern void far d3rotate (int points, int xorigin, int
               yorigin, int zorigin, int zrang, int yrang, int xrang,
               D3Point far *inary, D3Point far *outary)

            INPUT

            numpoints - number of points to be rotated
            xorigin, yorigin, zorigin - center of rotation
            zrang - angle of rotation about the Z axis
            yrang - angle of rotation about the Y axis
            xrang - angle of rotation about the X axis
            inary - D3Point pointer to array containing points to rotate

            OUTPUT

            no value returned
            outary - D3Point array of rotated values

            USAGE

            D3ROTATE takes the three dimensional points given in inary and
            rotates them by the specified angles about xorigin, yorigin,
            zorigin.  The results are returned in outary which can be the
            same as inary.  A virtual set of axes are placed at the origin
            of rotation and rotation takes place about these axes.  A
            positive angle causes a counter-clockwise rotation from the
            positive X axis to the positive Y axis.  The function assumes
            space for outary has been properly allocated.

            SEE ALSO

            D3PROJECT, D3SCALE, D3TRANSLATE

            EXAMPLE

            /*
             * shows d3rotate works
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            D2Point plot[8];

            void drwcube(void);

            void main(void)
            {
               int vmode,i,dummy;


                                                                         30







               ProjParameters proj;
               D3Point rcube[8];
               D3Point cube[8] = { { 100,-100, 100},
                                { 100,-100,-100},
                                { 100, 100,-100},
                                { 100, 100, 100},
                                {-100,-100, 100},
                                {-100,-100,-100},
                                {-100, 100,-100},
                                {-100, 100, 100}};

               vmode = videomodeget();
               if (!whichvga() || (whichmem() < 512))
                 exit(1);
               res640();

               proj.eyex = -1040;
               proj.eyey = -600;
               proj.eyez = -1200;
               proj.scrd = 1700;
               proj.theta = 30;
               proj.phi = 45;

               for(i=0;i<=360;i+=2)
               {
                 d3rotate(8,0,0,0,i,i,i,cube,rcube);
                 dummy = d3project(8,&proj,rcube,plot);
                 drwcube();
                 sdelay(2);
                 drwcube();
               }

               drwcube();

               getch();

               videomodeset(vmode);
            }

            void drwcube(void)
            {
               int j;

               for(j=0;j<=2;j++)

               drwline(2,10,plot[j].x,plot[j].y,plot[j+1].x,plot[j+1].y);
               drwline(2,10,plot[3].x,plot[3].y,plot[0].x,plot[0].y);

               for(j=4;j<=6;j++)

               drwline(2,10,plot[j].x,plot[j].y,plot[j+1].x,plot[j+1].y);
               drwline(2,10,plot[7].x,plot[7].y,plot[4].x,plot[4].y);

               for(j=0;j<=3;j++)


                                                                         31








               drwline(2,10,plot[j].x,plot[j].y,plot[j+4].x,plot[j+4].y);

               return;
            }



















































                                                                         32







          D3SCALE

            PROTOTYPE

            extern void far d3scale (int points, int xscale, int yscale,
               int zscale, D3Point far *inary, D3Point far *outary)

            INPUT

            numpoints - number of points to scale
            xscale - scale factor along X axis
            yscale - scale factor along Y axis
            zscale - scale factor along Z axis
            inary - D3Point pointer to array containing points to scale

            OUTPUT

            no value returned
            outary - D3Point array of scaled values

            USAGE

            D3SCALE multiplies each coordinate in the three dimensional
            array inary by the corresponding scale factor xscale, yscale
            or zscale.  The results are stored in outary which can be the
            same as inary.  A scale factor of 256 (100 hex) is considered
            100 percent and results in no change.  Therefore, 128 (80 hex)
            reduces values by one half and 512 (200 hex) doubles values.
            The function assumes space for outary has been properly
            allocated.

            SEE ALSO

            D3PROJECT, D3ROTATE, D3TRANSLATE

            EXAMPLE

            /*
             * shows d3scale works
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            D2Point plot[8];

            void drwcube(void);

            void main(void)
            {
               int vmode,i,dummy;
               ProjParameters proj;
               D3Point scube[8];


                                                                         33







               D3Point cube[8] = { { 100,-100, 100},
                                { 100,-100,-100},
                                { 100, 100,-100},
                                { 100, 100, 100},
                                {-100,-100, 100},
                                {-100,-100,-100},
                                {-100, 100,-100},
                                {-100, 100, 100}};

               vmode = videomodeget();
               if (!whichvga() || (whichmem() < 512))
                 exit(1);
               res640();

               proj.eyex = -1040;
               proj.eyey = -600;
               proj.eyez = -1200;
               proj.scrd = 1700;
               proj.theta = 30;
               proj.phi = 45;

               for(i=256;i>=128;i-=4)
               {
                 d3scale(8,i,i,i,cube,scube);
                 dummy = d3project(8,&proj,scube,plot);
                 drwcube();
                 sdelay(2);
                 drwcube();
               }
               for(i=132;i<=256;i+=4)
               {
                 d3scale(8,i,i,i,cube,scube);
                 dummy = d3project(8,&proj,scube,plot);
                 drwcube();
                 sdelay(2);
                 drwcube();
               }
               drwcube();
               getch();
               videomodeset(vmode);
            }

            void drwcube(void)
            {
               int j;

               for(j=0;j<=2;j++)

               drwline(2,10,plot[j].x,plot[j].y,plot[j+1].x,plot[j+1].y);
               drwline(2,10,plot[3].x,plot[3].y,plot[0].x,plot[0].y);

               for(j=4;j<=6;j++)

               drwline(2,10,plot[j].x,plot[j].y,plot[j+1].x,plot[j+1].y);


                                                                         34







               drwline(2,10,plot[7].x,plot[7].y,plot[4].x,plot[4].y);

               for(j=0;j<=3;j++)

               drwline(2,10,plot[j].x,plot[j].y,plot[j+4].x,plot[j+4].y);

               return;
            }
















































                                                                         35







          D3TRANSLATE

            PROTOTYPE

            extern void far d3translate (int points, int xtrans, int
               ytrans, int ztrans, D3Point far *inary, D3Point far *outary)

            INPUT

            numpoints - number of points to translate
            xtrans - distance to translate along X axis
            ytrans - distance to translate along Y axis
            ztrans - distance to translate along Z axis
            inary - D3Point pointer to array containing points to
            translate

            OUTPUT

            no value returned
            outary - D3Point array of translated points

            USAGE

            D3TRANSLATE takes the three dimensional points given in inary
            and translates them by the specified number of pixels along
            each axis.  The results are returned in outary which can be
            the same as inary.  The function assumes space for outary has
            been properly allocated.

            SEE ALSO

            D3PROJECT, D3ROTATE, D3SCALE

            EXAMPLE

            /*
             * shows d3translate works
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            D2Point plot[8];

            void drwcube(void);

            void main(void)
            {
               int vmode,i,dummy;
               ProjParameters proj;
               D3Point tcube[8];
               D3Point cube[8] = { { 100,-100, 100},
                                { 100,-100,-100},


                                                                         36







                                { 100, 100,-100},
                                { 100, 100, 100},
                                {-100,-100, 100},
                                {-100,-100,-100},
                                {-100, 100,-100},
                                {-100, 100, 100}};

               vmode = videomodeget();
               if (!whichvga() || (whichmem() < 512))
                 exit(1);
               res640();

               proj.eyex = -1040;
               proj.eyey = -600;
               proj.eyez = -1200;
               proj.scrd = 1700;
               proj.theta = 30;
               proj.phi = 45;

               for(i=0;i<=400;i+=8)
               {
                 d3translate(8,i,i,i,cube,tcube);
                 dummy = d3project(8,&proj,tcube,plot);
                 drwcube();
                 sdelay(2);
                 drwcube();
               }
               for(i=400;i>=0;i-=8)
               {
                 d3translate(8,i,i,i,cube,tcube);
                 dummy = d3project(8,&proj,tcube,plot);
                 drwcube();
                 sdelay(2);
                 drwcube();
               }
               drwcube();
               getch();
               videomodeset(vmode);
            }

            void drwcube(void)
            {
               int j;

               for(j=0;j<=2;j++)

               drwline(2,10,plot[j].x,plot[j].y,plot[j+1].x,plot[j+1].y);
               drwline(2,10,plot[3].x,plot[3].y,plot[0].x,plot[0].y);

               for(j=4;j<=6;j++)

               drwline(2,10,plot[j].x,plot[j].y,plot[j+1].x,plot[j+1].y);
               drwline(2,10,plot[7].x,plot[7].y,plot[4].x,plot[4].y);



                                                                         37







               for(j=0;j<=3;j++)

               drwline(2,10,plot[j].x,plot[j].y,plot[j+4].x,plot[j+4].y);

               return;
            }


















































                                                                         38







          DRWALINE

            PROTOTYPE

            extern void far drwaline (colrbits, int colr, int x1, int y1,
            int x2, int y2)

            INPUT

            colrbits - number of bits of color
            colr - index to color in current palette
            x1, y1 - location of one endpoint of line
            x2, y2 - location of other endpoint of line

            OUTPUT

            no value returned

            USAGE

            DRWALINE draws an antialiased line of the specified color
            using with endpoints located at (x1, y1) and (x2,y2).
            Antialiased lines trick the eye into seeing true vector lines
            instead of a jagged series of individual pixels.  This is
            accomplished by drawing two pixels of the same color but with
            different intensities (brightness) for each pixel drawn by
            DRWALINE.  The eye averages the pixels and sees only a
            straight line.  Note that the palette must be set up with the
            correct color entries for the line to look correct.  All
            values of x1, y1, x2 and y2 are valid.  Any portion of the
            line that lies outside of the currently defined viewport will
            not be drawn.  Colrbits should be a number in the range of 0
            to 6 specifying the number of shades of color in the palette
            (20 =1 is one color shade; 26=64 is 64 shades of color).
            These shades should be contiguous in the palette from index
            colr to index (colr + 2colrbits - 1) starting with the full
            desired brightness.  The best compromise of detail versus
            palette entries is about 3 (23=8 is 8 shades, or palette
            entries, of color).

            SEE ALSO

            DRWLINE, DRWBOX, SETVIEW

            EXAMPLE

            /*
             * Draws some normal and antialiased lines
             */

            #include <stdlib.h>
            #include <conio.h>
            #include <math.h>
            #include "svgacc.h"


                                                                         39








            void main(void)
            {
               int i,y,ya,yb,ofst,coloroffset,intsbits,numlevels,dummy;
               PaletteData pal;
               if ( !whichvga() )
                    exit(1);
                if ( whichmem() < 512)
                 exit(1);
                if ( !res640() )
                 exit(1);
               /* set up the palette */
               intsbits=2;
               numlevels=pow(2,intsbits);
               coloroffset=16;
               palget(pal,0,255);
               for (i=0;i<numlevels;i++) {
                 pal[i+coloroffset].r = (char)(63-35*i/(numlevels-1));
                 pal[i+coloroffset].g = (char)(63-35*i/(numlevels-1));
                 pal[i+coloroffset].b = (char)(63-35*i/(numlevels-1));
               }
               palset(pal,0,255);
               ofst=maxy/2;
               ya=maxy/3;
               yb=2*maxy/3;
               for(y=0;y<ofst;y=y+12) {
                 drwline(SET,15,0,ya,maxx,y);
                 drwaline(intsbits,16,0,yb,maxx,ofst+y);
               }
               getch();
               dummy=restext();
               exit(0);
            }























                                                                         40







          DRWBOX

            PROTOTYPE

            extern void far drwbox (PixelMode mode, int colr, int x1, int
            y1, int x2, int y2)

            INPUT

            mode - pixel write mode
            colr - index to color in current palette
            x1, y1 - location of top left corner
            x2, y2 - location of bottom right corner

            OUTPUT

            no value returned

            USAGE

            DRWBOX draws a rectangle with the specified color using mode
            with opposite vertices defined by (x1, y1) and (x2, y2).  The
            vertices given do not need to be exactly the top left and
            bottom right.  They only have to reference opposite vertices
            of the rectangle.  Any portion of the rectangle that lies
            outside of the currently defined viewport will not be drawn.

            SEE ALSO

            DRWFILLBOX, DRWLINE, SETVIEW

            EXAMPLE

            /*
             * Places a box around the whole screen
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               res640();
               drwbox (1,10,0,0,639,479);
               getch();
               videomodeset(vmode);


                                                                         41







               exit(0);
            }






















































                                                                         42







          DRWCIRARC

            PROTOTYPE

            extern void far drwcirarc (PixelMode mode, int colr, int
            xcenter, int ycenter, int radius, long startang, endaang)

            INPUT

            mode - pixel write mode (SET=1, XOR=2, OR=3, AND=4)
            colr - index to color in current palette
            xcenter, ycenter - location of center of circle
            radius - distance from center to edge of circle
            startang, endang - start and end angles in degrees

            OUTPUT

            no value returned

            USAGE

            DRWCIRARC draws a circular arc of the specified color and mode
            with the center located at (xcenter, ycenter), radius of
            radius, starting at the angle specified by startang and ending
            at the angle specified by endang.  All values of xcenter,
            ycenter, radius, startang, and endang are valid.  However,
            startang must be less than endang.  Any portion of the arc
            that lies outside of the currently defined viewport will not
            be drawn.

            SEE ALSO

            DRWCIRCLE, DRWELLARC

            EXAMPLE

            /*
             * draws some circular arcs
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int i,r,sang;

               if ( !whichvga() )
                    exit(1);
                if ( !res640() )
                 exit(1);

               for(i=0;i<=60;i++)


                                                                         43







               {
                 r=i*5;
                 sang=i*6;
                 drwcirarc (SET,10,maxx/2,maxy/2,r,sang,360);
               }
               getch();
               restext();
               exit(0);
            }















































                                                                         44







          DRWCIRCLE

            PROTOTYPE

            extern void far drwcircle (PixelMode mode, int colr, int
            xcenter, int ycenter, int radius)

            INPUT

            mode - pixel write mode
            colr - index to color in current palette
            xcenter, ycenter - location of center of circle
            radius - distance from center to edge of circle

            OUTPUT

            no value returned

            USAGE

            DRWCIRCLE draws a circle of the specified color using mode
            with the center located at (xcenter, ycenter) and a radius of
            radius.  All values of xcenter, ycenter and radius are valid.
            Any portion of the circle that lies outside of the currently
            defined viewport will not be drawn.

            SEE ALSO

            DRWCIRARC, DRWELLIPSE, DRWFILLCIRCLE, SETVIEW

            EXAMPLE

            /*
             * Places a circle at the center of the screen
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               res640();
               drwcircle (1,10,320,240,200);
               getch();
               videomodeset(vmode);
               exit(0);


                                                                         45







            }























































                                                                         46







          DRWCUBICBEZIER

            PROTOTYPE

            extern void far drwcubicbezier (PixelMode mode, int colr,
            D2Point far* pon1, D2Point far* poff1, D2Point far* poff2,
            D2Point far* pon2)

            INPUT

            mode - pixel write mode (SET=1, XOR=2, OR=3, AND=4)
            colr - index to color in current palette
            pon1 - D2Point pointer to the start point
            poff1 - D2Point pointer to the first control point
            poff2 - D2Point pointer to the second control point
            pon2 - D2Point pointer to the end point

            OUTPUT

            no value returned

            USAGE

            DRWCUBICBEZIER draws a standard cubic Bezier curve connecting
            the points pon1 and pon2 using the specified mode and color.
            The off-curve control points are poff1 and poff2.  A technical
            description of cubic Bezier curves is beyond the scope of this
            manual.  However, most advanced computer graphics texts
            contain discussions on this topic.

            SEE ALSO

            DRWCIRARC, DRWELLARC

            EXAMPLE

            /*
             * Places cubic bezier curve at the center of the screen
             */

            #include <conio.h>
            #include <stdio.h>
            #include <stdlib.h>
            #include "svgacc.h"

            void main(void)
            {
               D2Point work[4] = { {260, 240}, {310, 360}, {330, 120},
            {380, 240} };
               if(!whichvga()) {
                 printf("no id vga\n");
                 exit(1);
               }
               res640();


                                                                         47







               drwcircle(SET,12,work[0].x,work[0].y,2);
               drwcircle(SET,12,work[1].x,work[1].y,2);
               drwcircle(SET,12,work[2].x,work[2].y,2);
               drwcircle(SET,12,work[3].x,work[3].y,2);
               drwcubicbezier(SET,15,&work[0],&work[1],&work[2],&work[3]);

               while(!kbhit());
               getch();
               restext();
            }














































                                                                         48







          DRWELLARC

            PROTOTYPE

            extern void far drwellarc (PixelMode mode, int colr, int
            xcenter, int ycenter, int radiusx, int radiusy, long startang,
            long endaang)

            INPUT

            mode - pixel write mode (SET=1, XOR=2, OR=3, AND=4)
            color - index to color in current palette
            xcenter, ycenter - location of center of ellipse
            radiusx - radius parallel to X axis
            radiusy - radius parallel to Y axis
            startang, endang - start and end angles in degrees

            OUTPUT

            no value returned

            USAGE

            DRWELLARC draws an elliptical arc of the specified color and
            mode with the center located at (xcenter, ycenter).  The
            radius in the horizontal direction is raduisx and the radius
            in the vertical direction is radiusy.  The starting angle is
            specified by startang and ends at the angle specified by
            endang.  All values of xcenter, ycenter, radiusx, radiusy,
            startang and endang are valid.  However, startang must be less
            than endang.  Any portion of the arc that lies outside of the
            currently defined viewport will not be drawn.

            SEE ALSO

            DRWCIRARC, DRWELLIPSE

            EXAMPLE

            /*
             * draws some ellipital arcs
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int i,rx,ry,sang;

               if ( !whichvga() )
                    exit(1);
                if ( !res640() )


                                                                         49







                 exit(1);

               for(i=0;i<=60;i++)
               {
                 rx=i*5;
                 ry=i*3;
                 sang=i*6;
                 drwellarc (SET,10,maxx/2,maxy/2,rx,ry,sang,360);
               }
               getch();
               restext();
               exit(0);
            }











































                                                                         50







          DRWELLIPSE

            PROTOTYPE

            extern void far drwellipse (PixelMode mode, int colr, int
            xcenter, int ycenter, int radiusx, int radiusy)

            INPUT

            mode - pixel write mode
            colr - index to color in current palette
            xcenter, ycenter - location of center of ellipse
            radiusx - radius parallel to X axis
            radiusy - radius parallel to Y axis

            OUTPUT

            no value returned

            USAGE

            DRWELLIPSE draws an ellipse of the specified color using mode
            with the center defined by (xcenter, ycenter).  The radius in
            the horizontal direction is raduisx and the radius in the
            vertical direction is radiusy.  All values of xcenter,
            ycenter, radiusx and radiusy are valid.  Any portion of the
            ellipse that lies outside of the currently defined viewport
            will not be drawn.

            SEE ALSO

            DRWCIRCLE, DRWELLARC, DRWFILLELLIPSE, SETVIEW

            EXAMPLE

            /*
             * Places an ellipse at the center of the screen
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               res640();
               drwellipse (1,10,320,240,318,238);


                                                                         51







               getch();
               videomodeset(vmode);
               exit(0);
            }




















































                                                                         52







          DRWFILLBOX

            PROTOTYPE

            extern void far drwfillbox (PixelMode mode, int colr, int x1,
            int y1, int x2, int y2)

            INPUT

            mode - pixel write mode
            colr - index to color in current palette
            x1, y1 - location of top left corner
            x2, y2 - location of bottom right corner

            OUTPUT

            no value returned

            USAGE

            DRWFILLBOX draws a solid rectangle with the specified color
            using mode with opposite vertices defined by (x1, y1) and (x2,
            y2).  The vertices given do not need to be exactly the top
            left and bottom right.  They only have to reference opposite
            vertices of the rectangle.  Any portion of the rectangle that
            lies outside of the currently defined viewport will not be
            drawn.

            SEE ALSO

            DRWBOX, DRWLINE, FILLCONVEXPOLY, FILLPOLY, SETVIEW

            EXAMPLE

            /*
             * Places a filled box in the center of the screen
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;
               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                    exit(1);
               if ( !res640() )
                    exit(1);
               drwfillbox (1,10,270,190,370,290);
               getch();


                                                                         53







               videomodeset(vmode);
               exit(0);
            }





















































                                                                         54







          DRWFILLCIRCLE

            PROTOTYPE

            extern void far drwfillcircle (PixelMode mode, int colr, int
            xcenter, int ycenter, int radius)

            INPUT

            mode - pixel write mode
            colr - index to color in current palette
            xcenter, ycenter - location of center of circle
            radius - distance from center to edge of circle

            OUTPUT

            no value returned

            USAGE

            DRWFILLCIRCLE draws a solid circle of the specified color
            using mode with the center located at (xcenter, ycenter) and a
            radius of radius.  All values of xcenter, ycenter and radius
            are valid.  Any portion of the circle that lies outside of the
            currently defined viewport will not be drawn.

            SEE ALSO

            DRWCIRCLE, SETVIEW

            EXAMPLE

            /*
             * Places a filled circle at the center of the screen
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;
               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               if ( !res640() )
                 exit(1);
               drwfillcircle (1,10,320,240,100);
               getch();
               videomodeset(vmode);
               exit(0);


                                                                         55







            }























































                                                                         56







          DRWFILLELLIPSE

            PROTOTYPE

            extern void far drwfillellipse (PixelMode mode, int colr, int
            xcenter, int ycenter, int radiusx, int radiusy)

            INPUT

            mode - pixel write mode
            colr - index to color in current palette
            xcenter, ycenter - location of center of ellipse
            radiusx - radius parallel to X axis
            radiusy - radius parallel to Y axis

            OUTPUT

            no value returned

            USAGE

            DRWFILLELLIPSE draws an ellipse of the specified color using
            mode with the center defined by (xcenter, ycenter).  The
            radius in the horizontal direction is raduisx and the radius
            in the vertical direction is radiusy.  All values of xcenter,
            ycenter, radiusx and radiusy are valid.  Any portion of the
            ellipse that lies outside of the currently defined viewport
            will not be drawn.

            SEE ALSO

            DRWELLIPSE, SETVIEW

            EXAMPLE

            /*
             * Places a filled ellipse at the center of the screen
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;
               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               if ( !res640() )
               exit(1);
               drwfillellipse (1,10,320,240,218,138);


                                                                         57







               getch();
               videomodeset(vmode);
               exit(0);
            }




















































                                                                         58







          DRWLINE

            PROTOTYPE

            extern void far drwline (PixelMode mode, int colr, int x1, int
            y1, int x2, int y2)

            INPUT

            mode - pixel write mode
            colr - index to color in current palette
            x1, y1 - location of one endpoint of line
            x2, y2 - location of other endpoint of line

            OUTPUT

            no value returned

            USAGE

            DRWLINE draws a line of the specified color using mode with
            endpoints located at (x1, y1) And (x2, y2).  All values of x1,
            y1, x2 and y2 are valid.  Any portion of the line that lies
            outside of the currently defined viewport will not be drawn.

            SEE ALSO

            DRWALINE, DRWBOX, SETVIEW

            EXAMPLE

            /*
             * Draws a line from 0,0 to the center of the screen
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;
               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               res640();
               drwline (1,10,0,0,320,240);
               getch();
               videomodeset(vmode);
               exit(0);
            }



                                                                         59







          DRWPOINT

            PROTOTYPE

            extern void far drwpoint (PixelMode mode, int colr, int x, int
            y)

            INPUT

            mode - pixel write mode
            colr - index to color in current palette
            x, y - location of pixel to write

            OUTPUT

            no value returned

            USAGE

            DRWPOINT draws a single point of the specified color using
            mode at (x, y).  All values of x and y are valid.  If the
            point (x, y) lies outside of the currently defined viewport,
            no drawing will take place.

            SEE ALSO

            GETPOINT, SETVIEW

            EXAMPLE

            /*
             * Draws a point at the center of the screen
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               res640();
               drwpoint (1,10,320,240);
               getch();
               videomodeset(vmode);
               exit(0);
            }



                                                                         60







          DRWSTRING

            PROTOTYPE

            extern void far drwstring (PixelMode mode, int fcolr, int
            bcolr, const char far *strng, int x, int y)

            INPUT

            mode - pixel write mode
            fcolr - foreground index to color in current palette
            bcolr - background index to color in current palette
            strng - char pointer to string of ASCII characters to be drawn
            x, y - location of upper, left corner of block

            OUTPUT

            no value returned

            USAGE

            DRWSTRING takes the null terminated ASCII characters beginning
            at strng and creates a graphics block similar to the blocks
            used by blkget and blkput and places this block on the screen
            at the specified coordinates.  The characters are drawn with
            color fcolr using the current font and the background is color
            bcolr.  When mode 0, NO_ACTION, is used, the graphics block is
            created in memory, retrievable by GETLASTSTRING, but no text
            is actually drawn on the screen.  (Note: the system font is
            automatically installed when WHICHVGA is called.)

            SEE ALSO

            FONTSET, FONTGETINFO, FONTSYSTEM, DRWSTRINGDN, DRWSTRINGLT,
            DRWSTRINGRT, GETLASTSTRING

            EXAMPLE

            /*
             * Draws some normal text at the center of the screen
             */
            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;
               char text[]="hello world";

               vmode = videomodeget();
               if ( !whichvga() || (whichmem() < 512))
                 exit(1);
               res640();


                                                                         61







               drwstring(1,10,0,text,320,240);
               getch();
               videomodeset(vmode);
               exit(0);
            }



















































                                                                         62







          DRWSTRINGDN

            PROTOTYPE

            extern void far drwstringdn (PixelMode mode, int fcolr, int
            bcolr, const char far *strng, int x, int y)

            INPUT

            mode - pixel write mode
            fcolr - foreground index to color in current palette
            bcolr - background index to color in current palette
            strng - char pointer to string of ASCII characters to be drawn
            x, y - location of lower, right corner of block

            OUTPUT

            no value returned

            USAGE

            DRWSTRINGDN takes the null terminated ASCII characters
            beginning at strng and creates a graphics block similar to the
            blocks used by BLKGET and BLKPUT.  The characters are drawn
            with color fcolr using the current font and the background is
            color bcolr.  When mode 0, NO_ACTION, is used, the graphics
            block is created in memory retrievable by GETLASTSTRING, but
            no text is actually drawn on the screen.  (Note: the system
            font is automatically installed when WHICHVGA is called.)  The
            text is drawn upside down with x, y specifying the lower,
            right corner.  This corner corresponds to the upper, left
            corner when the text is oriented upright.

            SEE ALSO

            FONTSET, FONTGETINFO, FONTSYSTEM, DRWSTRING, DRWSTRINGLT,
            DRWSTRINGRT, GETLASTSTRING

            EXAMPLE

            /* Draws some text rotated by 180 degrees at the center of the
            screen */
            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;
               char text[]="hello world";

               vmode = videomodeget();
               if ( !whichvga() || (whichmem() < 512))
                 exit(1);


                                                                         63







               res640();
               drwstringdn(1,10,0,text,320,240);
               getch();
               videomodeset(vmode);
               exit(0);
            }


















































                                                                         64







          DRWSTRINGLT

            PROTOTYPE

            extern void far drwstringlt (PixelMode mode, int fcolr, int
            bcolr, const char far *strng, int x, int y)

            INPUT

            mode - pixel write mode
            fcolr - foreground index to color in current palette
            bcolr - background index to color in current palette
            strng - char pointer to string of ASCII characters to be drawn
            x, y - location of lower, left corner of block

            OUTPUT

            no value returned

            USAGE

            DRWSTRINGLT takes the null terminated ASCII characters
            beginning at strng and creates a graphics block similar to the
            blocks used by BLKGET and BLKPUT.  The characters are drawn
            with color fcolr using the current font and the background is
            color bcolr.  When mode 0, NO_ACTION, is used, the graphics
            block is created in memory retrievable by GETLASTSTRING, but
            no text is actually drawn on the screen.  (Note: the system
            font is automatically installed when WHICHVGA is called.)  The
            text block is rotated 90 to the left with x, y specifying the
            lower, left corner.  This corner corresponds to the upper,
            left corner when the text is oriented upright.

            SEE ALSO

            FONTSET, FONTGETINFO, FONTSYSTEM, DRWSTRING, DRWSTRINGDN,
            DRWSTRINGRT, GETLASTSTRING

            EXAMPLE

            /* Draws some text rotated 90 degrees to the left at center of
            screen */
            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;
               char text[]="hello world";

               vmode = videomodeget();
               if ( !whichvga() || (whichmem() < 512))
                 exit(1);


                                                                         65







               res640();
               drwstringlt(1,10,0,text,320,240);
               getch();
               videomodeset(vmode);
               exit(0);
            }


















































                                                                         66







          DRWSTRINGRT

            PROTOTYPE

            extern void far drwstringrt (PixelMode mode, int fcolr, int
            bcolr, const char far *strng, int x, int y)

            INPUT

            mode - pixel write mode
            fcolr - foreground index to color in current palette
            bcolr - background index to color in current palette
            strng - char pointer to string of ASCII characters to be drawn
            x, y - location of upper, right corner of block

            OUTPUT

            no value returned

            USAGE

            DRWSTRINGRT takes the null terminated ASCII characters
            beginning at strng and creates a graphics block similar to the
            blocks used by BLKGET and BLKPUT.  The characters are drawn
            with color fcolr using the current font and the background is
            color bcolr.  When mode 0, NO_ACTION, is used, the graphics
            block is created in memory retrievable by GETLASTSTRING, but
            no text is actually drawn on the screen.  (Note: the system
            font is automatically installed when WHICHVGA is called.)  The
            text block is rotated 90 to the right with x, y specifying the
            upper, right corner.  This corner corresponds to the upper,
            left corner if the text is oriented upright.

            SEE ALSO

            FONTSET, FONTGETINFO, FONTSYSTEM, DRWSTRING, DRWSTRINGDN,
            DRWSTRINGLT, GETLASTSTRING

            EXAMPLE

            /* Draws text rotated 90 degrees to the right at center of
            screen */
            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;
               char text[]="hello world";

               vmode = videomodeget();
               if ( !whichvga() || (whichmem() < 512))
                 exit(1);


                                                                         67







               res640();
               drwstringrt(1,10,0,text,320,240);
               getch();
               videomodeset(vmode);
               exit(0);
            }


















































                                                                         68







          FILLAREA

            PROTOTYPE

            extern void far fillarea (int xseed, int yseed, int
            bordercolr, int fillcolr)

            INPUT

            xseed, yseed - seed location to start fill
            bordercolr - index to color in current palette at which
            filling stops
            fillcolr - index to color in current palette to fill within
            the border

            OUTPUT

            no value returned

            USAGE

            FILLAREA fills a region with a new color specified by
            fillcolr.  The region is defined by any line or curve of the
            color bordercolr or fillcolr or by the edge of the viewport.
            All graphics within the region are lost and covered with the
            fillcolr.  The border is not effected.

            SEE ALSO

            DRWFILLBOX, DRWFILLCIRCLE, DRWFILLELLIPSE, FILLCOLOR,
            FILLCONVEXPOLY, FILLPOLY, FILLPAGE, FILLSCREEN, FILLVIEW,
            SETVIEW

            EXAMPLE

            /*
             * fills a box with some color
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               res640();
               drwbox(1,10,0,0,100,100);


                                                                         69







               fillarea(1,1,10,7);
               getch();
               videomodeset(vmode);
               exit(0);
            }



















































                                                                         70







          FILLCOLOR

            PROTOTYPE

            extern void far fillcolor (int xseed, int yseed, int oldcolr,
            int newcolr)

            INPUT

            xseed, yseed - seed location to start fill
            oldcolr - index to color in current palette to change
            newcolr - index to color in current palette to replace oldcolr

            OUTPUT

            no value returned

            USAGE

            FILLCOLOR replaces every existence of oldcolr with newcolr
            within a region.  The region is defined as any pixel of
            oldcolr which has a path of pixels of oldcolr or newcolr with
            sides touching back to the seed point, (xseed, yseed).
            Therefore, only pixels of oldcolr are modified and no other
            information is changed.

            SEE ALSO

            DRWFILLBOX, DRWFILLCIRCLE, DRWFILLELLIPSE, FILLAREA,
            FILLCONVEXPOLY, FILLPOLY, FILLPAGE, FILLSCREEN, FILLVIEW,
            SETVIEW

            EXAMPLE

            /*
             * replaces the black color with a new color
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               res640();
               drwbox(1,10,0,0,100,100);
               drwbox(1,12,20,20,80,80);


                                                                         71







               fillcolor(1,1,0,7);
               getch();
               videomodeset(vmode);
               exit(0);
            }



















































                                                                         72







          FILLCONVEXPOLY

            PROTOTYPE

            extern void far fillconvexpoly (int polycolr, int numpoints,
            D2Point far* pointarray)

            INPUT

            polycolor - index to color in current palette
            numpoints - number of points in PointArray
            pointarray - D2Point pointer to array containing polygon
            points

            OUTPUT

            no value returned

            USAGE

            FILLCONVEXPOLY draws a solid polygon outlined by the points
            given in pointarray.  The points are expected to be
            consecutive and the resulting polygon should be convex (ie.
            the polygon should not curve in on itself like a kidney bean).
            The function also assumes that the last point in the array
            connects to the first.

            SEE ALSO

            D3PROJECT, DRWFILLBOX, FILLAREA, FILLCOLOR, FILLPAGE,
            FILLPOLY, FILLSCREEN, FILLVIEW

            EXAMPLE

            /*
            * Show fillconvexpoly
            */

            #include <stdlib.h>
            #include <math.h>
            #include <conio.h>
            #include "svgacc.h"
            #define randnum(size) (rand() % (int)(size))

            D2Point tri[3];

            void main(void)
            {
               int vmode,colr,i;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)


                                                                         73







                 exit(1);
               if ( !res640() )
                 exit(1);

               for(i=0;i<99;i++) {
                 tri[0].x = randnum(maxx);
                 tri[0].y = randnum(maxy);
                 tri[1].x = randnum(maxx);
                 tri[1].y = randnum(maxy);
                 tri[2].x = randnum(maxx);
                 tri[2].y = randnum(maxy);
                 colr = randnum(15);
                 fillconvexpoly(colr,3,tri);
               }

               getch();
               videomodeset(vmode);
               exit(0);
            }





































                                                                         74







          FILLPAGE

            PROTOTYPE

            extern void far fillpage (int colr)

            INPUT

            colr - index to color in current palette

            OUTPUT

            no value is returned

            USAGE

            FILLPAGE clears the currently active page with the specified
            color.  All information on the page is lost.  (Note, a faster
            method to clear the page is to call any of the RES###
            functions.  These reset the graphics screen and automatically
            clear it to color index zero as well as reset the default
            palette.)

            SEE ALSO

            DRWFILLBOX, DRWFILLCIRCLE, DRWFILLELLIPSE, FILLAREA,
            FILLCOLOR, FILLCONVEXPOLY, FILLPOLY, FILLSCREEN, FILLVIEW

            EXAMPLE

            /*
             * fill the page with a color
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               res640();
               fillpage(10);
               getch();
               videomodeset(vmode);
               exit(0);
            }



                                                                         75







          FILLPOLY

            PROTOTYPE

            extern void far fillpoly (int polycolr, int numpoints, D2Point
            far *pointarray)

            INPUT

            polycolor - index to color in current palette
            numpoints - number of points in PointArray
            pointarray - D2Point pointer to array containing polygon
            points

            OUTPUT

            no value returned

            USAGE

            FILLPOLY draws a solid polygon outlined by the points given in
            pointarray.  The points are expected to be consecutive.
            However, there are no restrictions on the relative locations
            of the points.  The polygon may curve in on itself or have
            crossed lines.  The function also assumes that the last point
            in the array connects to the first.  FILLPOLY can be used
            interchangeably with FILLCONVEXPOLY, although FILLPOLY is
            slightly slower.

            Special thanks to Eric Jorgensen for providing the algorithm
            which formed the basis for FILLPOLY.

            SEE ALSO

            D3PROJECT, DRWFILLBOX, FILLAREA, FILLCOLOR, FILLCONVEXPOLY,
            FILLPAGE, FILLSCREEN, FILLVIEW

            EXAMPLE

            /*
            * Show fillpoly
            */

            #include <stdlib.h>
            #include <math.h>
            #include <conio.h>
            #include "svgacc.h"
            #define randnum(size) (rand() % (int)(size))

            void main(void)
            {
               D2Point star[5];

               if ( !whichvga() )


                                                                         76







                 exit(1);
               if ( whichmem() < 512)
               exit(1);
               if ( !res640() )
               exit(1);

               star[0].x = 320;
               star[0].y = 40;
               star[1].x = 203;
               star[1].y = 401;
               star[2].x = 510;
               star[2].y = 179;
               star[3].x = 130;
               star[3].y = 179;
               star[4].x = 437;
               star[4].y = 401;

               fillpoly(10,5,star);

               getch();
               restext();
               exit(0);
            }

































                                                                         77







          FILLSCREEN

            PROTOTYPE

            extern void far fillscreen (int colr)

            INPUT

            colr - index to color in current palette

            OUTPUT

            no value is returned

            USAGE

            FILLSCREEN clears the entire screen with the specified color.
            All information on the screen is lost.  (Note, a faster method
            to clear the screen is to call any of the RES### functions.
            These reset the graphics screen and automatically clear it to
            color index zero as well as reset the default palette.)

            SEE ALSO

            DRWFILLBOX, DRWFILLCIRCLE, DRWFILLELLIPSE, FILLAREA,
            FILLCOLOR, FILLCONVEXPOLY, FILLPAGE, FILLPOLY, FILLVIEW

            EXAMPLE

            /*
             * fill the screen with a color
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               res640();
               fillscreen(10);
               getch();
               videomodeset(vmode);
               exit(0);
            }




                                                                         78







          FILLVIEW

            PROTOTYPE

            extern void far fillview (int colr)

            INPUT

            colr - index to color in current palette

            OUTPUT

            no value is returned

            USAGE

            FILLVIEW fills the currently defined viewport with the
            specified color.  All information in the viewport is lost.

            SEE ALSO

            DRWFILLBOX, DRWFILLCIRCLE, DRWFILLELLIPSE, FILLAREA,
            FILLCOLOR, FILLCONVEXPOLY, FILLPAGE, FILLPOLY, FILLSCREEN,
            SETVIEW

            EXAMPLE

            /*
             * fill the viewport with a color
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               res640();
               setview(100,100,539,379);
               fillview(10);
               getch();
               videomodeset(vmode);
               exit(0);
            }





                                                                         79







          FONTGETINFO

            PROTOTYPE

            extern void far fontgetinfo (int far *wdth, int far *hght)

            INPUT

            no input parameters

            OUTPUT

            wdth - integer pointer to width in pixels of current font
            hght - integer pointer to height in pixels of current font

            USAGE

            FONTGETINFO returns in wdth and hght the dimensions of the
            currently loaded font.

            SEE ALSO

            FONTSET, FONTSYSTEM

            EXAMPLE

            /*
             * display system font width and height
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;
               int fontwidth;
               int fontheight;
               char text[50];

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               res640();
               fontgetinfo(&fontwidth,&fontheight);
               sprintf(text,"the system font width is: %d",fontwidth);
               drwstring(1,7,0,text,0,0);
               sprintf(text,"the system font height is: %d",fontheight);
               drwstring(1,7,0,text,0,20);
               getch();
               videomodeset(vmode);


                                                                         80







               exit(0);
            }






















































                                                                         81







          FONTSET

            PROTOTYPE

            extern void far fontset (Font far *font)

            INPUT

            font - pointer to Font structure

            OUTPUT

            no value returned

            USAGE

            FONTSET loads the current font with the data found at font.
            The Font structure is 4098 bytes long with the first two bytes
            being the width and height of the font respectively.

            SEE ALSO

            FONTGETINFO, FONTSYSTEM

            EXAMPLE

            /*
             * Load a font from disk and enable it
             */

            #include <stdlib.h>
            #include <conio.h>
            #include <stdio.h>
            #include "svgacc.h"

            Font newfont;

            void main(void)
            {
               int vmode;
               char text[]="The Dragon Font!";
               FILE *fontfile;
               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               if ( !res640() )
                 exit(1);
               if( (fontfile = fopen("dragon.fnt","rb")) == NULL )
                 exit (1);
               fread(&newfont,4098,1,fontfile);
               fclose(fontfile);
               fontset(&newfont);


                                                                         82







               drwstring(1,10,0,text,0,0);
               getch();
               videomodeset(vmode);
            }




















































                                                                         83







          FONTSYSTEM

            PROTOTYPE

            extern void far fontsystem (void)

            INPUT

            no input parameters

            OUTPUT

            no value returned

            USAGE

            FONTSYSTEM sets the current font to the standard system font.
            This font is automatically set when WHICHVGA is called.

            SEE ALSO

            WHICHVGA, FONTGETINFO, FONTSET

            EXAMPLE

            /* Load font from disk, enable it, and switch back to system
            font */

            #include <stdlib.h>
            #include <conio.h>
            #include <stdio.h>
            #include "svgacc.h"

            Font newfont;

            void main(void)
            {
               int vmode;
               char text1[]="The Dragon Font!";
               char text2[]="The System Font!";
               FILE *fontfile;
               vmode = videomodeget();
               if ( !whichvga() || (whichmem() < 512))
                 exit(1);
               if ( !res640() )
                 exit(1);
               if( (fontfile = fopen("dragon.fnt","rb")) == NULL )
                 exit(1);
               fread(&newfont,4098,1,fontfile);
               fclose(fontfile);
               fontset(&newfont);
               drwstring(1,10,0,text1,0,0);
               fontsystem();
               drwstring(1,10,0,text2,0,20);


                                                                         84







               getch();
               videomodeset(vmode);
            }





















































                                                                         85







          GETARCCOS

            PROTOTYPE

            extern long far getarccos (long cosvalue)

            INPUT

            cosvalue - number between -1 and +1 scaled up by 13 bits
            (8192)

            OUTPUT

            GETARCCOS returns the arc cosine of cosvalue in degrees.

            USAGE

            GETARCCOS returns the arc cosine in degrees for the given
            value.  The return will be between 0 and 180 degrees.
            Cosvalue should be between -8192 and +8192 representing the
            range -1 to +1.  Input values outside this range are invalid
            and GETARCCOS will return -32768.  This function uses an
            integer lookup table stored within the library in order to
            produce the fastest possible results.  No floating point
            arithmetic is used.  The scale factor of 13 bits (8192) was
            chosen because this is the number of bits at which every
            change of one degree gives a change in the value of the sine
            (or cosine) function.

            SEE ALSO

            GETARCSIN, GETARCTAN, GETCOS, GETSIN, GETTAN

            EXAMPLE

            /*
             * show getarccos
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int ang;
               long valueX8192;
               float value;

               for(value=0;value<1;value+=.05)
               {
                 valueX8192 = 8192 * value;
                 ang = getarccos(valueX8192);
                 printf("arccos of %f = %d degrees\n",value,ang);


                                                                         86







               }
               exit(0);
            }





















































                                                                         87







          GETARCSIN

            PROTOTYPE

            extern long far getarcsin (long sinvalue)

            INPUT

            sinvalue - number between -1 and +1 scaled up by 13 bits
            (8192)

            OUTPUT

            GETARCSIN returns the arc sine of sinvalue in degrees.

            USAGE

            GETARCSIN returns the arc sine in degrees for the given value.
            The return will be between -90 and +90 degrees.  Sinvalue
            should be between -8192 and +8192 representing the range -1 to
            +1.  Input values outside this range are invalid and GETARCSIN
            will return -32768.  This function uses an integer lookup
            table stored within the library in order to produce the
            fastest possible results.  No floating point arithmetic is
            used.  The scale factor of 13 bits (8192) was chosen because
            this is the number of bits at which every change of one degree
            gives a change in the value of the sine (or cosine) function.

            SEE ALSO

            GETARCCOS, GETARCTAN, GETCOS, GETSIN, GETTAN

            EXAMPLE

            /*
             * show getarcsin
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int ang;
               long valueX8192;
               float value;

               for(value=0;value<1;value+=.05)
               {
                 valueX8192 = 8192 * value;
                 ang = getarcsin(valueX8192);
                 printf("arcsin of %f = %d degrees\n",value,ang);
               }


                                                                         88







               exit(0);
            }






















































                                                                         89







          GETARCTAN

            PROTOTYPE

            extern long far getarctan (long tanvalue)

            INPUT

            tanvalue - long integer representing a decimal scaled up by 13
            bits (8192)

            OUTPUT

            GETARCTAN returns the arc tangent of tanvalue in degrees.

            USAGE

            GETARCTAN returns the arc tangent in degrees for the given
            value.  The return will be between -89 and +89 degrees.
            Tanvalue can be any long integer.  It is interpreted as a
            decimal scaled up by 8192 (13 bits).  This function uses an
            integer lookup table stored within the library in order to
            produce the fastest possible results.  No floating point
            arithmetic is used.  The scale factor of 13 bits (8192) was
            chosen because this is the number of bits at which every
            change of one degree gives a change in the value of the sine
            (or cosine) function.

            SEE ALSO

            GETARCCOS, GETARCSIN, GETCOS, GETSIN, GETTAN

            EXAMPLE

            /*
             * show getarctan
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int tanang;
               int ang;
               long valueX8192;
               float value;

               for(value=0;value<2;value+=.1)
               {
                 valueX8192 = 8192 * value;
                 ang = getarctan(valueX8192);
                 printf("arctan of %f = %d degrees\n",value,ang);


                                                                         90







               }
               exit(0);
            }





















































                                                                         91







          GETCOS

            PROTOTYPE

            extern long far getcos (long angle)

            INPUT

            angle - angle in degrees

            OUTPUT

            GETCOS returns the cosine of angle scaled up by 13 bits
            (8192).

            USAGE

            GETCOS returns the cosine of the specified angle.  Angle can
            be any long value.  The return value has been multiplied by
            8192.  This function uses an integer lookup table stored
            within the library in order to produce the fastest possible
            results.  No floating point arithmetic is used.  The scale
            factor of 13 bits (8192) was chosen because this is the number
            of bits at which every change of one degree gives a change in
            the value of the sine (or cosine) function.

            SEE ALSO

            GETARCCOS, GETARCSIN, GETARCTAN, GETSIN, GETTAN

            EXAMPLE

            /*
             * show getcos
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int ang;
               float value;

               for(ang=0;ang<90;ang+=5)
               {
                 value = (float)getcos(ang) / 8192;
                 printf("cos of %d degrees = %f\n",ang,value);
               }
               exit(0);
            }




                                                                         92







          GETLASTSTRING

            PROTOTYPE

            extern void far getlaststring (RasterBlock far *strnggfxblk)

            INPUT

            no input parameters

            OUTPUT

            no value returned
            strnggfxblk - RasterBlock pointer to destination array

            USAGE

            GETLASTSTRING returns the text drawn on the screen by the last
            called DRWSTRING function.  The text is returned in
            strnggfxblk which may be used with BLKPUT or the sprite
            functions.  The text in strnggfxblk is oriented in the same
            manner as the last called DRWSTRING function.  The suggested
            practice is to call the DRWSTRING function using mode
            NO_ACTION which does not actually draw text on the screen.
            GETLASTSTRING should be called immediately after the desired
            DRWSTRING function to prevent possible loss of data caused by
            other functions.

            The number of bytes of raster data needed by strnggfxblk is
            equal to

                         (fontwidth*stringlength)*(fontheight)

            plus four bytes for the width and height integers in the
            RasterBlock structure.

            The font's dimensions can be obtained by calling FONTGETINFO
            and the string's length can be obtained using the STRLEN
            function.  Note, however, that strnggfxblk can be quite large.
            If insufficient space is allocated for strnggfxblk,
            GETLASTSTRING will overwrite any data in memory contained
            beyond strnggfxblk and may possibly cause the system to crash.

            SEE ALSO

            BLKPUT, DRWSTRING, DRWSTRINGDN, DRWSTRINGLT, DRWSTRINGRT,
            FONTGETINFO

            EXAMPLE

            /*
             * Draws some text using the 'NO-ACTION' mode then
             * retrieve the raster data as a 'RasterBlock'
             */


                                                                         93








            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode,fontwidth,fontheight;
               char text[]="hello world";
               RasterBlock *blkdata;
               vmode = videomodeget();
               if ( !whichvga() || (whichmem() < 512))
                 exit(1);
               if ( !res640() )
                 exit(1);
               drwstringrt(NO_ACTION,10,0,text,320,240);
               fontgetinfo(&fontwidth,&fontheight);
               blkdata = (RasterBlock *)malloc(fontwidth*11*fontheight +
            4);
               getlaststring(blkdata);
               blkput(SET,0,0,blkdata);
               getch();
               videomodeset(vmode);
            }
































                                                                         94







          GETPOINT

            PROTOTYPE

            extern int far getpoint (int x, int y)

            INPUT

            x, y - location of pixel to read

            OUTPUT

            GETPOINT returns the color index of the pixel at x, y.

            USAGE

            GETPOINT returns the value of the pixel at location x, y.
            This value is a color index into the current palette.

            SEE ALSO

            DRWPOINT

            EXAMPLE

            /*
             * draw a point and check that it is there
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;
               int pointvalue;
               char text[50];

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               res640();
               drwpoint(1,10,320,240);
               pointvalue = getpoint(320,240);
               sprintf(text,"the point value is: %d",pointvalue);
               drwstring(1,7,0,text,0,0);
               getch();
               videomodeset(vmode);
               exit(0);
            }



                                                                         95







          GETSIN

            PROTOTYPE

            extern long far getsin (long angle)

            INPUT

            angle - angle in degrees

            OUTPUT

            GETSIN returns the sine of angle scaled up by 13 bits (8192).

            USAGE

            GETSIN returns the sine of the specified angle.  Angle can be
            any long value.  The return value has been multiplied by 8192.
            This function uses an integer lookup table stored within the
            library in order to produce the fastest possible results.  No
            floating point arithmetic is used.  The scale factor of 13
            bits (8192) was chosen because this is the number of bits at
            which every change of one degree gives a change in the value
            of the sine (or cosine) function.

            SEE ALSO

            GETARCCOS, GETARCSIN, GETARCTAN, GETCOS, GETTAN

            EXAMPLE

            /*
             * show getsin
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int sinang, ang;
               float value;

               for(ang=0;ang<90;ang+=5)
               {
                 value = (float)getsin(ang) / 8192;
                 printf("sin of %d degrees = %f\n",ang,value);
               }
               exit(0);
            }





                                                                         96







          GETTAN

            PROTOTYPE

            extern long far gettan (long angle)

            INPUT

            angle - angle in degrees

            OUTPUT

            GETTAN returns the tangent of angle scaled up by 13 bits
            (8192)

            USAGE

            GETTAN returns the tangent of the specified angle.  Angle can
            be any long value except +(90+n*180), where n is an integer.
            The return value has been multiplied by 8192.  If an invalid
            angle is given, the GETTAN will return &H80000000 (-
            2147483648).  This function uses an integer lookup table
            stored within the library in order to produce the fastest
            possible results.  No floating point arithmetic is used.  The
            scale factor of 13 bits (8192) was chosen because this is the
            number of bits at which every change of one degree gives a
            change in the value of the sine (or cosine) function.

            SEE ALSO

            GETARCCOS, GETARCSIN, GETARCTAN, GETCOS, GETSIN

            EXAMPLE

            /*
             * show gettan
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int tanang, ang;
               float value;

               for(ang=0;ang<90;ang+=5)
               {
                 value = (float)gettan(ang) / 8192;
                 printf("tan of %d degrees = %f\n",ang,value);
               }
               exit(0);
            }


                                                                         97







           JOYSTICKINFO

            PROTOTYPE

            extern void far joystickinfo (int far *jax, int far *jay, int
            far *jabuts, int far *jbx, int far *jby, int far *jbbuts)

            INPUT

            no input parameters

            OUTPUT

            jax, jay - horizontal and vertical values of joystick A
            jabuts - button status of joystick A
            jbx, jby - horizontal and vertical values of joystick B
            jbbuts - button status of joystick B

            USAGE

            JOYSTICKINFO returns the current status of the two joysticks'
            position and buttons.  The position is returned in jax, jay
            for joystick A and jbx, jby for joystick B.  The buttons'
            status is held in jabuts and jbbuts.  For each joystick,
            button A - usually the fire button - is held in bit zero and
            button B is in bit one.  Button status is most easily checked
            with a bitwise AND of jabuts (or jbbuts) and the desired bit.

            Not all joysticks are constructed with the same components.
            In addition, joysticks are not linear devices.  The value of a
            joystick's center will not necessarily be the mean of its
            extreme values.  Therefore, it is recommended that any program
            using the joystick for more than just directional control
            complete a calibration of the joystick prior to usage.  For an
            example of joystick calibration, see the SVGADEMO.EXE source
            code.

            It is recommended, though not required, to call WHICHJOYSTICK,
            prior to using the joysticks in order to verify the existence
            of the hardware.

            SEE ALSO

            WHICHJOYSTICK

            EXAMPLE

            /*
             * show joysticks port readings
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"


                                                                         98








            void main(void)
            {
               int vmode;
               int jax, jay, jabuts, jbx, jby, jbbuts;

               printf("A:  X    Y  btn | B:  X    Y  btn\n  ");
               while(!kbhit()) {
                 joystickinfo(&jax,&jay,&jabuts,&jbx,&jby,&jbbuts);
                 printf("%04d %04d  %1d  |   ",jax,jay,jabuts);
                 printf("%04d %04d  %1d",jbx,jby,jbbuts);
                 printf("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b");
                 printf("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b");
               }
               getch();
            }








































                                                                         99







          MOUSEBUTPRESS

            PROTOTYPE

            extern void far mousebutpress (int reqbut, int far *xloc, int
            far *yloc, int far *num, int far *mbuts)

            INPUT

            reqbut - button for which information is requested

            OUTPUT

            x, y - current location of mouse cursor
            num - number of times requested button has been pressed since
            last request
            mbuts - current status of mouse buttons

            USAGE

            MOUSEBUTPRESS returns in Num the number of times a mouse
            button has been pressed since the last call to MOUSEBUTPRESS.
            In addition the current status of the mouse cursor and buttons
            is returned.  The position is returned in X, Y.  The buttons'
            status is held in mbuts.  The left button is held in bit zero,
            right button in bit one and center button - for three button
            mice - in bit two.  Button status is most easily checked with
            a bitwise AND of mbuts and the desired bit.  The button for
            which a history is desired is identified by the bits in
            reqbut.  However, only one bit in reqbut may be set.
            Therefore, only the values of 1, 2 and 4 are permitted.  If
            more than one bit in reqbut is set, the function will exit and
            no information will be returned.

            SEE ALSO

            MOUSEBUTRELEASE, MOUSESTATUS

            EXAMPLE

            /* enable,show mouse / display left button press history for
            the last 2
             * seconds
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode, x, y, n, mbuts;
               char text[50];



                                                                        100







               char textclr[]="
            ";

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               if ( !whichmouse())
                 exit(1);
               res640();
               mousecursordefault();
               mouseenter();
               mouseshow();
               while(!kbhit())
               {
                 mousebutpress(1,&x,&y,&n,&mbuts);
                 sprintf(text,"mouse x loc: %3d, y loc: %3d, number of
            times: %2d",x,y,n);
                 mousehide();
                 drwstring(1,15,8,text,0,0);
                 mouseshow();
                 sdelay(80);
                 mousehide();
                 drwstring(1,15,8,textclr,0,0);
                 mouseshow();
               }
               mousehide();
               mouseexit();
               videomodeset(vmode);
               exit(0);
            }
























                                                                        101







          MOUSEBUTRELEASE

            PROTOTYPE

            extern void far mousebutrelease (int reqbut, int far *xloc,
            int far *yloc, int far *num, int far *mbuts)

            INPUT

            reqbut - button for which information is requested

            OUTPUT

            x, y - current location of mouse cursor
            num - number of times requested button has been released since
            last request
            mbuts - current status of mouse buttons

            USAGE

            MOUSEBUTRELEASE returns in Num the number of times a mouse
            button has been released since the last call to
            MOUSEBUTRELEASE.  In addition the current status of the mouse
            cursor and buttons is returned.  The position is returned in
            x, y.  The buttons' status is held in mbuts.  The left button
            is held in bit zero, right button in bit one and center button
            - for three button mice - in bit two.  Button status is most
            easily checked with a bitwise AND of mbuts and the desired
            bit.  The button for which a history is desired is identified
            by the bits in reqbut.  However, only one bit in reqbut may be
            set.  Therefore, only the values of 1, 2 and 4 are permitted.
            If more than one bit in reqbut is set, the function will exit
            and no information will be returned.

            SEE ALSO

            MOUSEBUTPRESS, MOUSESTATUS

            EXAMPLE

            /* enable,show mouse / display left button release history for
            the last
             * 2 seconds
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode, x, y, n, mbuts;
               char text[50];



                                                                        102







               char textclr[]="
            ";

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               if ( !whichmouse())
                 exit(1);
               res640();
               mousecursordefault();
               mouseenter();
               mouseshow();
               while(!kbhit())
               {
                 mousebutrelease(1,&x,&y,&n,&mbuts);
                 sprintf(text,"mouse x loc: %3d, y loc: %3d, number of
            times: %2d",x,y,n);
                 mousehide();
                 drwstring(1,15,8,text,0,0);
                 mouseshow();
                 sdelay(80);
                 mousehide();
                 drwstring(1,15,8,textclr,0,0);
                 mouseshow();
               }
               mousehide();
               mouseexit();
               videomodeset(vmode);
               exit(0);
            }
























                                                                        103







          MOUSECURSORSET

            PROTOTYPE

            extern void far mousecursorset (MouseCursor far *mousecursor)

            INPUT

            mousecursor - MouseCursor pointer to mouse cursor data

            OUTPUT

            no value returned

            USAGE

            MOUSECURSORSET defines the cursor according to the data in the
            MouseCursor structure.  The hot spot for the cursor is set by
            mousecursor.hotspotx, mousecursor.hotspoty.  The values for
            mousecursor.hotspotx and mousecursor.hotspoty must be within
            the cursor.  Valid mousecursor.hotspotx values are from 0 to
            15 and mousecursor.hotspoty ranges from 0 to 23.

            SEE ALSO

            MOUSECURSORDEFAULT, MOUSEENTER, MOUSESHOW

            EXAMPLE

            /*
             * enable,show mouse, and switch to a different mouse cursor
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;

               MouseCursor bigmousecursor = {
                 1,1,

               0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,
                 0,15,15,0,0,255,255,255,255,255,255,255,255,255,255,255,
                 0,15,15,15,15,0,0,0,255,255,255,255,255,255,255,255,
                 0,15,15,15,15,15,15,15,0,0,255,255,255,255,255,255,
                 0,15,15,15,15,15,15,15,15,15,0,0,0,255,255,255,
                 0,15,15,15,15,15,15,15,15,15,15,15,15,0,0,255,
                 0,15,15,15,15,15,15,15,15,15,15,15,15,15,0,255,
                 0,15,15,15,15,15,15,15,15,15,15,15,0,0,255,255,
                 0,15,15,15,15,15,15,15,15,15,15,0,255,255,255,255,
                 0,15,15,15,15,15,15,15,15,0,0,255,255,255,255,255,


                                                                        104







                 0,15,15,15,15,15,15,15,15,0,255,255,255,255,255,255,
                 0,15,15,15,15,15,0,15,15,15,0,255,255,255,255,255,
                 0,15,15,15,15,0,0,15,15,15,0,255,255,255,255,255,
                 0,15,15,0,0,255,255,0,15,15,15,0,255,255,255,255,
                 0,15,0,255,255,255,255,0,15,15,15,0,255,255,255,255,
                 0,0,255,255,255,255,255,255,0,15,15,15,0,255,255,255,
                 255,255,255,255,255,255,255,255,255,0,15,15,15,0,255,255,
                 255,255,255,255,255,255,255,255,255,0,15,15,15,0,255,255,
                 255,255,255,255,255,255,255,255,255,255,0,15,15,15,0,255,
                 255,255,255,255,255,255,255,255,255,255,255,0,15,15,15,0,
                 255,255,255,255,255,255,255,255,255,255,255,0,15,15,15,0,

               255,255,255,255,255,255,255,255,255,255,255,255,0,15,15,0,

               255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,

               255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
            255
               };

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               if ( !whichmouse())
                 exit(1);
               res640();
               mouseenter();
               drwstring(1,7,0,"press a key to return to default
            cursor",0,0);
               mousecursorset(bigmousecursor);
               mouseshow();
               getch();
               mousecursordefault();
               drwstring(1,7,0,"press a key to end
            ",0,0);
               getch();
               mousehide();
               mouseexit();
               videomodeset(vmode);
               exit(0);
            }













                                                                        105







          MOUSECURSORDEFAULT

            PROTOTYPE

            extern void far mousecursordefault (void)

            INPUT

            no input parameters

            OUTPUT

            no value returned

            USAGE

            MOUSECURSORDEFAULT defines the mouse cursor to be a small
            arrow with the hot spot in the upper, left corner.  This is
            the cursor set when MOUSEENTER is called.

            SEE ALSO

            MOUSECURSORSET, MOUSEENTER

            EXAMPLE

            See MOUSECURSORSET





























                                                                        106







          MOUSEENTER

            PROTOTYPE

            extern void far mouseenter (void)

            INPUT

            no input parameters

            OUTPUT

            no value returned

            USAGE

            MOUSEENTER must be called before any other mouse functions.
            It initializes all of the mouse abilities including installing
            the Zephyr mouse display driver.  MOUSEENTER initializes the
            default mouse cursor, the default sensitivity and sets the
            range to the current screen resolution.  The mouse cursor
            location is set to the middle of the screen.

            SEE ALSO

            MOUSEEXIT, MOUSEHIDE, MOUSESHOW

            EXAMPLE

            /*
             * enable,show mouse
             */
            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               if ( !whichmouse())
                 exit(1);
               res640();
               mouseenter();
               mouseshow();
               getch();
               mousehide();
               mouseexit();
               videomodeset(vmode);


                                                                        107







               exit(0);
            }






















































                                                                        108







          MOUSEEXIT

            PROTOTYPE

            extern void far mouseexit (void)

            INPUT

            no input parameters

            OUTPUT

            no value returned

            USAGE

            MOUSEEXIT properly disables all of the mouse abilities.  This
            function also removes the Zephyr mouse display driver.  This
            function should be called prior to exiting any program that
            previously called MOUSEENTER.

            SEE ALSO

            MOUSEENTER, MOUSEHIDE, MOUSESHOW

            EXAMPLE

            /*
             * enable,show mouse, then disable it
             */
            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               if ( !whichmouse())
                 exit(1);
               res640();
               mousecursordefault();
               mouseenter();
               mouseshow();
               getch();
               mousehide();
               mouseexit();
               videomodeset(vmode);
               exit(0);


                                                                        109







            }























































                                                                        110







          MOUSEHIDE

            PROTOTYPE

            extern void far mousehide (void)

            INPUT

            no input parameters

            OUTPUT

            no value returned

            USAGE

            MOUSEHIDE turns off the mouse display driver and removes the
            cursor from the display.  It is recommended to hide the mouse
            any time something will be drawn in its general vicinity.
            Note, however, that although the cursor is not visible, all
            other mouse abilities remain active.

            SEE ALSO

            MOUSEENTER, MOUSEEXIT, MOUSESHOW

            EXAMPLE

            /*
             * enable,show mouse,hide mouse
             */
            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"
            void main(void)
            {
               int vmode;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               if ( !whichmouse())
                 exit(1);
               res640();
               mousecursordefault();
               mouseenter();
               mouseshow();
               getch();
               mousehide();
               getch();
               mouseexit();
               videomodeset(vmode);


                                                                        111







               exit(0);
            }






















































                                                                        112







          MOUSEINFO

            PROTOTYPE

            extern void far mouseinfo (int far *drvmajorver, int far
            *drvminorver, int far *mousetype, int far *irqnumber)

            INPUT

            no input parameters

            OUTPUT

            drvmajorver - Microsoft compatible mouse driver major version
            number
            drvminorver - Microsoft compatible mouse driver minor version
            number
            mousetype - type of mouse installed
            irqnumber - interrupt used by the mouse

            USAGE

            MOUSEINFO returns information about the mouse and its
            installed driver.  The driver must be Microsoft compatible.
            This information can be used to determine whether the mouse
            functions in this library will operate correctly.  For proper
            operation the driver version number must be greater than 1.00.
            Irqnumber gives the interrupt number of the mouse.  Mousetype
            returns information about the type of hardware installed
            according to the following table:

            0 =  unknown type
            1 =  bus mouse
            2 =  serial mouse
            3 =  Inport mouse
            4 =  PS/2 mouse
            5 =  HP mouse

            SEE ALSO

            WHICHMOUSE

            EXAMPLE

            /*
             * id any installed mouse
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {


                                                                        113







               int mjv, mnv, tp, i, mouse;
               char buf[100];

               mouse = whichmouse();
               if (mouse > 0) {
                 mouseinfo(&mjv, &mnv, &tp, &i);
                 switch (tp) {
                    case 1:
                      sprintf(buf,"bus mouse");
                      break;
                    case 2:
                      sprintf(buf,"serial mouse");
                      break;
                    case 3:
                      sprintf(buf,"Inport mouse");
                      break;
                    case 4:
                      sprintf(buf,"PS/2 mouse");
                      break;
                    case 5:
                      sprintf(buf,"HP mouse");
                      break;
                    default:
                      sprintf(buf,"unknown type");
                 }
                 printf("Microsoft compatible %s detected with %d buttons
            on IRQ %d.\n", &buf, mouse, i);
                 printf("Software driver version is %d.%d (Microsoft
            equivalent version).\n\n", mjv, mnv);

               } else
                 printf("No Microsoft compatible mouse detected.\n\n");
            }























                                                                        114







          MOUSELOCSET

            PROTOTYPE

            extern void far mouselocset (int xloc, int yloc)

            INPUT

            x, y - location on screen

            OUTPUT

            no value returned

            USAGE

            MOUSELOCSET moves the mouse cursor the location on the screen
            specified by x, y.  If either x or y is outside of the
            currently permitted mouse range, it is set to the closest
            border.  The currently permitted mouse range is the current
            screen resolution or the last called MOUSERANGESET.

            SEE ALSO

            MOUSEENTER, MOUSERANGESET

            EXAMPLE

            /*
             * enable,show mouse then move it to the origin
             */
            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"
            void main(void)
            {
               int vmode;
               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               if ( !whichmouse())
                 exit(1);
               res640();
               mousecursordefault();
               mouseenter();
               mouseshow();
               getch();
               mouselocset(0,0);
               getch();
               mousehide();
               mouseexit();
               videomodeset(vmode);


                                                                        115







               exit(0);
            }






















































                                                                        116







          MOUSERANGESET

            PROTOTYPE

            extern void far mouserangeset (int x1, int y1, int x2, int y2)

            INPUT

            x1, y1 - location on screen of top, left corner of range
            x2, y2 - location on screen of bottom, right corner of range

            OUTPUT

            no value returned

            USAGE

            MOUSERANGESET defines a permissible range on the screen for
            mouse movement.  The mouse is automatically positioned in the
            center of this range.

            SEE ALSO

            MOUSELOCSET, MOUSESTATUS

            EXAMPLE

            /*
             * enable,show and set a range for the mouse
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;
               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               if ( !whichmouse())
                 exit(1);
               if ( !res640() )
                 exit(1);
               mouseenter();
               drwbox(1,10,100,100,539,379);
               mouserangeset(100,100,539,379);
               mouseshow();
               getch();
               mousehide();
               mouseexit();


                                                                        117







               videomodeset(vmode);
               exit(0);
            }





















































                                                                        118







          MOUSERESTORESTATE

            PROTOTYPE

            extern void far mouserestorestate (byte far *mousebuf)

            INPUT

            mousebuf - byte pointer to buffer holding complete mouse
            status information

            OUTPUT

            no value returned

            USAGE

            MOUSERESTORESTATE completely restores a previously saved mouse
            status as contained in mousebuf.  The mouse status must have
            been already stored in mousebuf by MOUSESAVESTATE.

            SEE ALSO

            MOUSESAVESTATE, MOUSESTORAGESIZE

            EXAMPLE

            /*
             * save the mouse driver state,shell out to DOS, restore the
            driver state
             */

            #include <stdlib.h>
            #include <conio.h>
            #include <process.h>
            #include "svgacc.h"

            void main(void)
            {
               int rt, bufsiz;
               byte *mousedriverdata;
               char cmdcom[]="C:\COMMAND.COM";
               char *args[1];

               if ( !whichmouse())
                 exit(1);
               bufsiz=mousestoragesize();
               mousedriverdata = (byte *)malloc(bufsiz);
               mousesavestate(mousedriverdata);
               printf("* Type Exit To Return To Program *");
               args[0]=NULL;
               rt=spawnv(P_WAIT,cmdcom,args);
               mouserestorestate(mousedriverdata);
               printf("mouse driver data restored...");


                                                                        119







               exit(0);
            }






















































                                                                        120







          MOUSESAVESTATE

            PROTOTYPE

            extern void far mousesavestate (byte far *mousebuf)

            INPUT

            no input parameters

            OUTPUT

            no value returned
            mousebuf - buffer holding complete mouse status information

            USAGE

            MOUSESAVESTATE saves the complete mouse status in mousebuf.
            The size of mousebuf in bytes is defined by MOUSESTORAGESIZE
            which should called first.

            SEE ALSO

            MOUSERESTORESTATE, MOUSESTORAGESIZE

            EXAMPLE

            See MOUSERESTORESTATE




























                                                                        121







          MOUSESENSSET

            PROTOTYPE

            extern void far mousesensset (int xsens, int ysens, int
            dblspdthresh)

            INPUT

            xsens = number of mickeys per 8 pixels horizontally (default =
            4 mickeys per pixel)
            ysens = number of mickeys per 8 pixels vertically (default = 4
            mickeys per pixel)
            dblspdthresh=number of mickeys per second at which speed is
            doubled (default = 8)

            OUTPUT

            no value returned

            USAGE

            MOUSESENSSET defines the relationship between mouse movement
            and cursor movement on the screen.  A mickey is defined as
            1/200th of an inch.  The ratio between mickeys and pixels is
            specified by xsens and ysens in the horizontal and vertical
            directions respectively.  When the mouse movement is faster
            than DblSpdThresh in mickeys per second, the speed is doubled.
            The default values are assigned whenever MOUSEENTER or
            MOUSEEXIT are called.

            SEE ALSO

            MOUSEENTER, MOUSEEXIT, MOUSESTATUS

            EXAMPLE

            /*
             * enable,show the mouse and make it very sensitive
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"
            void main(void)
            {
               int vmode;
               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               if ( !whichmouse())
                 exit(1);


                                                                        122







               res640();
               mousecursordefault();
               mouseenter();
               mouseshow();
               mousesensset(2, 2, 4);
               getch();
               mousehide();
               mouseexit();
               videomodeset(vmode);
               exit(0);
            }













































                                                                        123







          MOUSESHOW

            PROTOTYPE

            extern void far mouseshow (void)

            INPUT

            no input parameters

            OUTPUT

            no value returned

            USAGE

            MOUSESHOW enables the mouse display driver and places the
            cursor on the screen.  The cursor is only updated when the
            mouse is moved.  Therefore, it is recommended to hide the
            cursor when drawing on the screen to avoid unexpected results.

            SEE ALSO

            MOUSEENTER, MOUSEEXIT, MOUSEHIDE

            EXAMPLE

            See MOUSEHIDE




























                                                                        124







          MOUSESTATUS

            PROTOTYPE

            extern void far mousestatus (int far *x, int far *y, int far
            *mbuts)

            INPUT

            no input parameters

            OUTPUT

            x, y - mouse position on screen
            mbuts - status of mouse buttons

            USAGE

            MOUSESTATUS returns the current status of the mouse position
            and buttons.  The position is returned in x, y.  The buttons'
            status is held in mbuts.  The left button is held in bit zero,
            right button in bit one and center button - for three button
            mice - in bit two.  Button status is most easily checked with
            a bitwise AND of mbuts and the desired bit.

            SEE ALSO

            MOUSERANGESET, MOUSESENSSET

            EXAMPLE

            /* enable,show mouse & display status */
            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode, x, y, mbuts;
               char buf[100];

               vmode = videomodeget();
               if ( !whichvga() || (whichmem() < 512))
                 exit(1);
               if ( !whichmouse())
                 exit(1);
               res640();
               mouseenter();
               mouseshow();
               while(!kbhit()) {
                 mousestatus(&x,&y,&mbuts);
                 sprintf(buf,"X= %4d  Y= %4d  LB= %1d  CB= %1d  RB=
            %1d\0",x,y,(mbuts & 1),(mbuts & 2),(mbuts & 4));
                 drwstring(1,15,8,buf,10,32);


                                                                        125







               }
               mousehide();
               mouseexit();
               videomodeset(vmode);
            }



















































                                                                        126







          MOUSESTORAGESIZE

            PROTOTYPE

            extern int far mousestoragesize (void)

            INPUT

            no input parameters

            OUTPUT

            MOUSESTORAGESIZE returns the size of buffer in bytes to store
            complete mouse status

            USAGE

            MOUSESTORAGESIZE determines the proper size buffer to hold the
            complete mouse status information.  This buffer should be
            allocated before calling MOUSESAVESTATE.

            SEE ALSO

            MOUSERESTORESTATE, MOUSESAVESTATE

            EXAMPLE

            /*
             * return the size in bytes need to save the mouse driver
            status
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int bufsiz;
               char buf[50];

               if ( !whichmouse())
                 exit(1);

               bufsiz=mousestoragesize();
               sprintf(buf,"%d bytes are required to save mouse driver
            status...",bufsiz);
               printf("%s", &buf);
               exit(0);
            }






                                                                        127







          OVERSCANSET

            PROTOTYPE

            extern void far overscanset (int colr)

            INPUT

            colr - index to color in current palette

            OUTPUT

            no value returned

            USAGE

            OVERSCANSET sets the overscan region to the specified color.
            The overscan region is the area between the usable pixel area
            and the region not scanned by the monitor.  Normally, the
            overscan is color zero which is defined as black the majority
            of the time.  The overscan color is reset to zero anytime a
            RES### function is called.

            Note: OVERSCANSET always works in the 320x200 resolution.  In
            the higher resolutions on many common SVGA cards this function
            is ignored.  Instead, the card always assigns the overscan
            region to color zero.  Therefore, it is recommended to not use
            OVERSCANSET, but assign color zero as needed.

            EXAMPLE

            /*
             * set the overscan color to green
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;
               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               res320();
               overscanset(10);
               getch();
               videomodeset(vmode);
               exit(0);
            }





                                                                        128







          PAGEACTIVE

            PROTOTYPE

            extern int far pageactive (int page)

            INPUT

            page - number of page to make active

            OUTPUT

            PAGEACTIVE returns a 1 if successful, 0 if unsuccessful.

            USAGE

            PAGEACTIVE sets the active page as specified by page.  It
            works by creating an offset to be added when any bank
            switching is performed.  This function does not affect the
            actual display.  A page is defined as the number of 64K banks
            necessary to contain the current screen resolution.  For
            example, 640x480 requires 307,200 bytes which is a little more
            than 4.5 64K blocks.  One page in this resolution will be 5
            banks.

            PAGEACTIVE does not work in 320x200 mode since this mode uses
            no bank switching.

            SEE ALSO

            FILLPAGE, PAGEDISPLAY

            EXAMPLE

            /*
            * Show pageactive (video card needs 1meg to show pages in
            640x480x256)
            */

            #include <stdlib.h>
            #include <math.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode,er;
               char text[]="press a key...";
               char buf[20];
               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 1024)
                 exit(1);


                                                                        129







               if ( !res640() )
                 exit(1);
               /* make sure video card supports page flipping */
               if ( !pagedisplay(0,0,0) ) {
                 videomodeset(vmode);
                 exit(1);
               }
               er = pageactive(0);
               fillpage(0);
               drwstring(1,10,0,text,0,300);
               sprintf(buf,"Page 0");
               drwstring(1,10,0,buf,0,0);
               er = pageactive(1);
               fillpage(0);
               drwstring(1,12,0,text,0,300);
               sprintf(buf,"Page 1");
               drwstring(1,12,0,buf,0,20);
               er = pageactive(2);
               fillpage(0);
               drwstring(1,13,0,text,0,300);
               sprintf(buf,"Page 2");
               drwstring(1,13,0,buf,0,40);
               er = pageactive(0);
               er = pagedisplay(0,0,0);
               getch();
               er = pagedisplay(0,0,1);
               getch();
               er = pagedisplay(0,0,2);
               getch();
               videomodeset(vmode);
               exit(0);
            }
























                                                                        130







          PAGEDISPLAY

            PROTOTYPE

            extern int far pagedisplay (int x, int y, int page)

            INPUT

            x, y - coordinate to place at top, left of display
            page - number of page to make active

            OUTPUT

            PAGEDISPLAY returns a 1 if successful, 0 if unsuccessful.

            USAGE

            PAGEDISPLAY tells the video card where in video memory to
            begin the display.  This display offset is calculated from the
            specified page, x and y.  This is done by multiplying y times
            the width of the current resolution, adding x and then adding
            the appropriate number of 64K blocks for page.  X, y and page
            must all be positive numbers, but are otherwise not
            restricted.  The display will wrap if the values are
            abnormally large.  Wrapping will happen from side to side as
            well as from top of memory to bottom of memory.

            PAGEDISPLAY does not work in 320x200 mode since this mode uses
            no bank switching.  In addition, older models of some SVGA
            cards operating in native mode do not support paging.  In this
            library these cards are: Acumos, Ahead version A, Everex and
            Genoa.  To ensure compatibility, a program should make a call
            similar to:

               if ( !pagedisplay(0,0,0) )
                 printf("PAGING NOT SUPPORTED\n");

            Note: SVGA cards by ATI Technologies appear to ignore bit 4
            (counting from 0 to 19) in its linear addressing mode and
            assume it is zero.  Therefore, bit 4 of the x parameter will
            be ignored by ATI chipsets.

            SEE ALSO

            FILLPAGE, PAGEACTIVE

            EXAMPLE

            See PAGEACTIVE







                                                                        131







          PALCHGAUTO

            PROTOTYPE

            extern void far palchgauto (RGB far *pal, RGB far *newpal, int
            firstcolr, int lastcolr, int speed)

            INPUT

            pal - initial palette
            newpal - new palette
            firstcolr - index into palette where change will begin
            lastcolr - index into palette where change will end
            speed - speed of change

            OUTPUT

            no value returned

            USAGE

            PALCHGAUTO smoothly fades the colors between firstcolr and
            lastcolr from the palette pal to newpal.  The speed of the
            fade is set by speed which is percentage change between each
            step of the fade.  Only values between 1 and 128 are valid
            where 1 represents a one percent change between steps and 128
            (80 hex) represents fifty percent change between steps.  A
            speed of 128 would then have only two steps.  A speed outside
            of the valid range causes the function to immediately return
            without making any changes.  The time required to accomplish
            the entire fade is approximately equal to 0.033 seconds times
            256 divided by speed.  PALCHGAUTO does not modify either pal
            or newpal.

            SEE ALSO

            PALCHGSTEP, PALDIMSTEP, PALIOAUTO

            EXAMPLE

            /*
             * autofade from one palette to another and back again
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode, colr, y, i, index;
               PaletteData orgpal, newpal;

               vmode = videomodeget();


                                                                        132







               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               res640();
               palget(orgpal,0,255);
               for (index=0;index<256;index++) {
                 newpal[index].r = index / 4;
                 newpal[index].g = index / 4;
                 newpal[index].b = index / 4;
               }
               colr = 0;
               for (y=0;y<480;y++) {
                 drwline(1,colr++,0,y,639,y);
                 if (colr>255)
                    colr = 0;
               }
               palchgauto(orgpal,newpal,0,255,2);
               palchgauto(newpal,orgpal,0,255,2);
               getch();
               videomodeset(vmode);
               exit(0);
            }

































                                                                        133







          PALCHGSTEP

            PROTOTYPE

            extern void far palchgstep (RGB far *pal, RGB far *newpal, int
            firstcolr, int lastcolr, int percent)

            INPUT

            pal - initial palette
            newpal - new palette
            firstcolr - index into palette where change will begin
            lastcolr - index into palette where change will end
            percent - percent step from current palette to new palette

            OUTPUT

            no value returned

            USAGE

            PALCHGSTEP changes the palette colors between firstcolr and
            lastcolr by percent from pal to newpal.  This function works
            very much like PALCHGAUTO except it only takes a single step
            and returns.  The step taken is a percentage specified by
            Percent where 256 (100 hex) is a 100 percent change.  The
            valid range for Percent is 0 to 256.  Values beyond this range
            cause the function to immediately return without making any
            changes.  A loop from 4 to 256 by fours using PALCHGSTEP would
            have similar results as PALCHGAUTO with a speed of 4.  Neither
            pal, nor newpal are modified.

            SEE ALSO

            PALCHGAUTO, PALDIMSTEP, PALIOAUTO

            EXAMPLE

            /*
             * step fade from one palette to another and back again
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode, colr, y, i, index;
               PaletteData orgpal, newpal;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);


                                                                        134







               if ( whichmem() < 512)
                 exit(1);
               res640();

               palget(orgpal,0,255);
               for (index=0;index<256;index++)
               {
                 newpal[index].r = index / 4;
                 newpal[index].g = index / 4;
                 newpal[index].b = index / 4;
               }
               colr = 0;
               for (y=0;y<480;y++)
               {
                 drwline(1,colr++,0,y,639,y);
                 if (colr>255)
                    colr = 0;
               }
               for (index=0;index<256;index++)
               {
                 palchgstep(orgpal,newpal,0,255,index);
               }
               for (index=256;index>=-1;index--)
               {
                 palchgstep(orgpal,newpal,0,255,index);
               }
               getch();
               videomodeset(vmode);
               exit(0);
            }


























                                                                        135







          PALCOPY

            PROTOTYPE

            extern void far palcopy (RGB far *srcpal, RGB far *destpal,
            int firstcolr, int lastcolr)

            INPUT

            srcpal - source palette
            firstcolr - index into palette where copy will begin
            lastcolr - index into palette where copy will end

            OUTPUT

            no value returned
            destpal - copy of srcpal

            USAGE

            PALCOPY quickly copies a source palette into a second palette
            array.  Destpal must be previously allocated.  A portion of a
            palette may be copied by specifying first and last colors.  If
            firstcolr is greater than lastcolr, no copy will occur.

            SEE ALSO

            BYTECOPY

            EXAMPLE

            /*
             * create a color palette(grayscale) and copy it to a palette
             * of a different name
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode,colr,y,i,index;
               PaletteData pal, newpal;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               if ( !res640() )
                 exit(1);
               for (index=0;index<256;index++) {
                 pal[index].r = index / 4;


                                                                        136







                 pal[index].g = index / 4;
                 pal[index].b = index / 4;
               }
               colr = 0;
               palcopy(pal,newpal,0,255);
               for (y=0;y<480;y++) {
                 drwline(1,colr++,0,y,639,y);
                 if (colr>255)
                    colr = 0;
               }
               palset(newpal,0,255);
               getch();
               videomodeset(vmode);
               exit(0);
            }









































                                                                        137







          PALDIMSTEP

            PROTOTYPE

            extern void far paldimstep (RGB far *pal, int firstcolr, int
            lastcolr, int percent)

            INPUT

            pal - initial palette
            firstcolr - index into palette where dim will begin
            lastcolr - index into palette where dim will end
            percent - percent step from current palette to black

            OUTPUT

            no value returned

            USAGE

            PALDIMSTEP fades the specified palette to black by the given
            percentage between firstcolr and lastcolr.  The percentage
            step from pal to black is specified by percent where 256 (100
            hex) is full black.  The valid range for Percent is 0 to 256.
            Values beyond this range cause the function to immediately
            return without making any changes.  pal is not modified.

            SEE ALSO

            PALCHGAUTO, PALCHGSTEP, PALIOAUTO

            EXAMPLE

            /*
             * step dim from a palette to black and back again
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;
               int colr;
               int y;
               int i;
               int index;
               PaletteData orgpal;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)


                                                                        138







                 exit(1);
               res640();
               palget(orgpal,0,255);
               colr = 0;
               for (y=0;y<480;y++)
               {
                 drwline(1,colr++,0,y,639,y);
                 if (colr>255)
                    colr = 0;
               }
               for (index=0;index<256;index++)
               {
                 paldimstep(orgpal,0,255,index);
               }
               for (index=256;index>=-1;index--)
               {
                 paldimstep(orgpal,0,255,index);
               }
               getch();
               videomodeset(vmode);
               exit(0);
            }


































                                                                        139







          PALGET

            PROTOTYPE

            extern void far palget (RGB far *pal, int firstcolr, int
            lastcolr)

            INPUT

            firstcolr - index into palette where get will begin
            lastcolr - index into palette where get will end

            OUTPUT

            pal - copy of the current palette in the specified range

            USAGE

            PALGET returns in pal the colors from the current palette
            between firstcolr and lastcolr.  Only colors in the specified
            range are returned and all others in pal are unchanged.  Pal
            must be 768 bytes in length despite the number of colors
            retrieved.

            SEE ALSO

            PALROTATE, PALSET

            EXAMPLE

            See PALCHGAUTO

























                                                                        140







          PALIOAUTO

            PROTOTYPE

            extern void far palioauto (RGB far *pal, int firstcolr, int
            lastcolr, int speed)

            INPUT

            pal - initial palette
            firstcolr - index into palette where fade will begin
            lastcolr - index into palette where fade will end
            speed - speed of fade

            OUTPUT

            no value returned

            USAGE

            PALIOAUTO smoothly fades the colors between firstcolr and
            lastcolr of pal to or from solid black.  The speed of the fade
            is set by speed which is the percentage change between each
            step of the fade.  A positive speed corresponds to fading from
            pal to black and a negative speed fades from black to Pal.
            Only values between -128 and +128 are valid where  1
            represents a one percent change between steps and  128 ( 80
            hex) represents fifty percent change between steps.  A speed
            of 128 would then have only two steps.  A speed outside of the
            valid range causes the function to immediately return without
            making any changes.  The time required to accomplish the
            entire fade is approximately equal to 0.033 seconds times 256
            divided by speed.  PALIOAUTO does not modify pal.

            SEE ALSO

            PALCHGAUTO, PALCHGSTEP, PALDIMSTEP

            EXAMPLE

            /*
             * autofade a palette to black and back again
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode, colr, y;
               PaletteData orgpal;

               vmode = videomodeget();


                                                                        141







               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               res640();
               colr = 0;
               palget(orgpal,0,255);
               for (y=0;y<480;y++) {
                 drwline(1,colr++,0,y,639,y);
                 if (colr>255)
                    colr = 0;
               }
               palioauto(orgpal,0,255,-2);
               palioauto(orgpal,0,255,2);
               getch();
               videomodeset(vmode);
               exit(0);
            }






































                                                                        142







          PALROTATE

            PROTOTYPE

            extern void far palrotate (RGB far *pal, int firstcolr, int
            lastcolr, int shift)

            INPUT

            pal - PaletteData pointer to current palette
            firstcolr - index into palette where shift will begin
            lastcolr - index into palette where shift will end
            shift - number of locations to shift colors

            OUTPUT

            no value returned

            USAGE

            PALROTATE shifts the colors in pal between firstcolr and
            lastcolr by a given number of locations and sets this new
            palette.  The number of locations the colors are moved is
            specified by shift which is between 1 and 256.  Pal is not
            modified by PALROTATE.

            SEE ALSO

            PALGET, PALSET

            EXAMPLE

            /*
             * rotate a few palette entries around
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode, colr, y, i, index;
               PaletteData orgpal;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               res640();
               colr = 0;
               palget(orgpal,0,255);
               for (y=0;y<480;y++) {


                                                                        143







                 drwline(1,colr++,0,y,639,y);
                 if (colr>255)
                    colr = 0;
               }
               for (i=0;i<200;i++) {
                 palrotate(orgpal,1,127,1);
                 palget(orgpal,0,255);
               }
               getch();
               videomodeset(vmode);
               exit(0);
            }












































                                                                        144







          PALSET

            PROTOTYPE

            extern void far palset (RGB far *pal, int firstcolr, int
            lastcolr)

            INPUT

            pal - palette to set
            firstcolr - index into palette where set will begin
            lastcolr - index into palette where set will end

            OUTPUT

            no value returned

            USAGE

            PALSET sets the specified range of colors in the current
            palette with the corresponding range in the palette pal.

            SEE ALSO

            PALGET

            EXAMPLE

            See PALCOPY



























                                                                        145







          PCXGETINFO

            PROTOTYPE

            extern int far pcxgetinfo (const char far *name, int far
               *pcxxsize, int far *pcxysize, int far *numcolors, RGB far
               *pal)

            INPUT

            name - char pointer to the filename of the PCX image to read

            OUTPUT

            PCXGETINFO returns 1 if successful, error code otherwise.
            pcxxsize - width in pixels of the image
            pcxysize - height in pixels of the image
            numcolors - number of colors in the image palette
            palette - copy of image palette

            USAGE

            PCXGETINFO reads name and returns the characteristics of the
            image.  The dimensions of the image are returned in pcxxsize,
            pcxysize.  The number of colors in the image's palette is
            returned in numcolors and the palette is returned in palette.
            Although the image's palette may contain less than 256 colors,
            palette must be 768 bytes in length.  The image's palette will
            begin with the first color in Palette.

            PCX version 3.0 is the only specification for 256 color
            images.  Therefore, only version 3.0 PCX files are accepted.

            If PCXGETINFO determines that Filename is a satisfactory file,
            the function will return a one.  Otherwise, the function will
            return one of several error codes as listed below:

            0 =  does not exist or there is some disk I/O problem
            -1 = not a version 3.0 PCX file
            -2 = not run-length-encoded
            -3 = general error

            SEE ALSO

            PCXMAKE, PCXPUT

            EXAMPLE

            /*
             * show the info on the 'zephyr.pcx' PCX file
             */

            #include <stdlib.h>
            #include <conio.h>


                                                                        146







            #include "svgacc.h"

            void main(void)
            {
               int vmode, xsize, ysize, numcol, ok;
               int i, darkcolor, britecolor, currcolor;
               PaletteData pcxpal;
               char buf[80];
               char fname[] = "zephyr.pcx";

               vmode = videomodeget();
               if ( !whichvga() || (whichmem() < 512))
                 exit(1);

               ok = pcxgetinfo(fname,&xsize,&ysize,&numcol,pcxpal);

               if (ok == 1) {
                 if ( !res640() )
                    exit(1);

                 /* we have an unknown 8 bit palette and we must cut it
            down to
                    6 bits and find the brightest and darkest colors */
                 darkcolor = 0 + 0 + 0;
                 britecolor = 63 + 63 + 63;
                 for(i=0;i<255;i++) {
                    pcxpal[i].r >>= 2;
                    pcxpal[i].g >>= 2;
                    pcxpal[i].b >>= 2;
                    currcolor = pcxpal[i].r + pcxpal[i].g + pcxpal[i].b;
                    if (currcolor > darkcolor)
                      darkcolor = currcolor;
                    if (currcolor < britecolor)
                      britecolor = currcolor;
                 }
                 palset(pcxpal,0,255);
                 fillscreen(darkcolor);
                 sprintf(buf,"'%s' is identified as a v3.0 PCX
            image.",fname);
                 drwstring(1,britecolor,darkcolor,buf,0,0);
                 sprintf(buf,"Dimensions are: %d pixels wide and %d pixels
            high.",xsize,ysize);
                 drwstring(1,britecolor,darkcolor,buf,0,16);
                 sprintf(buf,"Number of colors: %d.",numcol);
                 drwstring(1,britecolor,darkcolor,buf,0,32);
                 pcxput(SET,0,100,fname);
               } else {
                 printf("error in pcx file, error code: %d\n",ok);
               }
               getch();
               videomodeset(vmode);
            }




                                                                        147







          PCXMAKE

            PROTOTYPE

            extern int far pcxmake (int x1, int y1, int x2, int y2, const
            char far *name)

            INPUT

            x1, y1 - the location of the top, left corner of the image
            x2, y2 - the bottom, right corner of the image
            name - filename to store the PCX image

            OUTPUT

            PCXMAKE returns a 1 if successful, 0 if unsuccessful.

            USAGE

            PcxMAKE takes the bitmap enclosed in the box defined by (x1,
            y1) - (x2, y2) and writes a PCX with the filename specified by
            name.  The resulting file uses the PCX version 3.0
            specifications.  The values x1, y1, x2 and y2 must be valid
            coordinates on the currently active page.  Name may specify a
            full path and drive letter, if necessary.

            If PCXPUT encounters no problems, the function will return a
            one.  Otherwise, the function will return one of several error
            codes concerning Filename$ as listed below:

            0 =  disk I/O problem
            -1 = coordinates out of range

            SEE ALSO

            PCXGETINFO, PCXPUT

            EXAMPLE

            /*
             * Make a simple PCX file
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"
            #define randnum(size) (rand() % (int)(size))

            void main(void)
            {
               int vmode,colr,num,i;
               int x1,y1,x2,y2,er;
               char text[]="This PCX was made using Zephyr Software's
            PCXMAKE function!";


                                                                        148







               char fname[]="test.pcx";

               vmode = videomodeget();
               if ( !whichvga() || (whichmem() < 512))
                 exit(1);
               if ( !res640() )
                 exit(1);
               fillscreen(10);
               colr = 1;
               for(i=0;i<200;i++) {
                 x1 = randnum(maxx);
                 y1 = randnum(maxy);
                 x2 = randnum(maxx);
                 y2 = randnum(maxy);
                 drwline(1,colr++,x1,y1,x2,y2);
                 if (colr>15)
                    colr = 1;
               }
               drwbox(SET,15,0,0,maxx,maxy);
               drwstring(1,15,0,text,60,10);
               er = pcxmake(0,0,maxx,maxy,fname);
               if (er != 1 ) {
                 videomodeset(vmode);
                 exit(1);
               }

               videomodeset(vmode);
               exit(0);
            } 



























                                                                        149







          PCXPUT

            PROTOTYPE

            extern int far pcxput (PixelMode mode, int xloc, int yloc,
            const char far *name)

            INPUT

            mode - pixel write mode
            xloc, yloc - the location of the top, left corner of the PCX
            image
            name - char pointer to filename of the PCX image to read

            OUTPUT

            PCXPUT returns 1 if successful, error code otherwise.

            USAGE

            PCXPUT reads the PCX image from name and places it on the
            screen with the top, left corner at xloc, yloc.  The image is
            automatically clipped to the currently defined viewport.  The
            image's palette should be previously obtained by using
            PCXGETINFO.

            PCX version 3.0 is the only specification for 256 color
            images.  Therefore, only version 3.0 PCX files are accepted.

            If PCXPUT encounters no problems, the function will return a
            one.  Otherwise, the function will return one of several error
            codes as listed below:

            0 =  does not exist or there is some disk I/O problem
            -1 = not a version 3.0 PCX file
            -2 = not run-length-encoded
            -3 = general error

            SEE ALSO

            PCXGETINFO, PCXMAKE, SETVIEW

            EXAMPLE

            See PCXGETINFO











                                                                        150







          RES320

            PROTOTYPE

            extern int far res320 (void)

            INPUT

            no input parameters

            OUTPUT

            RES320 always returns a 1.

            USAGE

            RES320 sets video mode 0x13 which is the industry standard
            320x200 graphics mode with 256 colors.  This function can be
            called without calling WHICHVGA first as this function
            requires only that a VGA card is present, not a Super VGA
            card.  If a VGA is not present, the system may crash.

            SEE ALSO

            RES640, RES640L, RES800, RES1024, RES1280, WHICHVGA

            EXAMPLE

            /*
             * set video mode to 320x200x256
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit();
               res320();
               drwstring(1,7,0,"this is the 320x200x256 video
            mode...",0,0);
               getch();
               videomodeset(vmode);
               exit(0);
            }






                                                                        151







          RES640

            PROTOTYPE

            extern int far res640 (void)

            INPUT

            no input parameters

            OUTPUT

            RES640 returns 1 if successful, 0 otherwise.

            USAGE

            RES640 sets the video mode to 640x480 graphics mode with 256
            colors.  This function requires that a Super VGA card with at
            least 512K of video memory be present.  Also, WHICHVGA must be
            called first or the function will fail without changing the
            video mode.  If the video card does not have sufficient
            memory, RES640 will return without changing the video mode.

            SEE ALSO

            RES320, RES640L, RES800, RES1024, RES1280, WHICHVGA

            EXAMPLE

            /*
             * set video mode to 640x480x256
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512 )
                 exit(1);
               res640();
               drwstring(1,7,0,"this is the 640x480x256 video
            mode...",0,0);
               getch();
               videomodeset(vmode);
               exit(0);
            }



                                                                        152







          RES640L

            PROTOTYPE

            extern int far res640l (void)

            INPUT

            no input parameters

            OUTPUT

            RES640L returns 1 if successful, 0 otherwise.

            USAGE

            RES640L sets the video mode to 640x400 graphics mode with 256
            colors.  This function requires that a Super VGA card with at
            least 256K of video memory be present.  Also, WHICHVGA must be
            called first or the function will fail without changing the
            video mode.  If the video card does not have sufficient
            memory, RES640L will return without changing the video mode.

            Note: The 640x400 is an uncommon resolution.  Many SVGA cards
            do not support this mode.

            SEE ALSO

            RES320, RES640, RES800, RES1024, RES1280, WHICHVGA

            EXAMPLE

            /*
             * set video mode to 640x400x256
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               res640l();
               drwstring(1,7,0,"this is the 640x400x256 video
            mode...",0,0);
               getch();
               videomodeset(vmode);
               exit(0);
            }


                                                                        153







          RES800

            PROTOTYPE

            extern int far res800 (void)

            INPUT

            no input parameters

            OUTPUT

            RES800 returns 1 if successful, 0 otherwise.

            USAGE

            RES800 sets the video mode to 800x600 graphics mode with 256
            colors.  This function requires that a Super VGA card with at
            least 512K of video memory be present.  Also, WHICHVGA must be
            called first or the function will fail without changing the
            video mode.  If the video card does not have sufficient
            memory, RES800 will return without changing the video mode.

            SEE ALSO

            RES320, RES640, RES640L, RES1024, RES1280, WHICHVGA

            EXAMPLE

            /*
             * set video mode to 800x600x256
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512 )
                 exit(1);
               res800();
               drwstring(1,7,0,"this is the 800x600x256 video
            mode...",0,0);
               getch();
               videomodeset(vmode);
               exit(0);
            }



                                                                        154







          RES1024

            PROTOTYPE

            extern int far res1024 (void)

            INPUT

            no input parameters

            OUTPUT

            RES1024 returns 1 if successful, 0 otherwise.

            USAGE

            RES1024 sets the video mode to 1024x768 graphics mode with 256
            colors.  This function requires that a Super VGA card with at
            least 1 Megabyte of video memory be present.  Also, WHICHVGA
            must be called first or the function will fail without
            changing the video mode.  If the video card does not have
            sufficient memory, RES1024 will return without changing the
            video mode.

            SEE ALSO

            RES320, RES640, RES640L, RES800, RES1280, WHICHVGA

            EXAMPLE

            /*
             * set video mode to 1024x768x256
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 1024 )
                 exit(1);
               res1024();
               drwstring(1,7,0,"this is the 1024x768x256 video
            mode...",0,0);
               getch();
               videomodeset(vmode);
               exit(0);
            }


                                                                        155







          RES1280

            PROTOTYPE

            extern int far res1280 (void)

            INPUT

            no input parameters

            OUTPUT

            RES1280 returns 1 if successful, 0 otherwise.

            USAGE

            RES1280 sets the video mode to 1280x1024 graphics mode with
            256 colors.  This function requires that a Super VGA card with
            at least 2 Megabytes of video memory be present.  Also,
            WHICHVGA must be called first or the function will fail
            without changing the video mode.  If the video card does not
            have sufficient memory, RES1280 will return without changing
            the video mode.

            SEE ALSO

            RES320, RES640, RES640L, RES800, RES1024, WHICHVGA

            EXAMPLE

            /*
             * set video mode to 1280x1024x256
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 2048 )
                 exit(1);
               res1024();
               drwstring(1,7,0,"this is the 1280x1024x256 video
            mode...",0,0);
               getch();
               videomodeset(vmode);
               exit(0);
            }


                                                                        156







          RESTEXT

            PROTOTYPE

            extern int far restext (void)

            INPUT

            no input parameters

            OUTPUT

            RESTEXT always returns a 1.

            USAGE

            RESTEXT sets video mode three which is the industry standard
            80x25 text mode.

            SEE ALSO

            VIDEOMODEGET, VIDEOMODESET

            EXAMPLE

            /*
             * set video mode to standard DOS text mode 3
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;

               vmode = videomodeget();
               if ( !restext() )
                 exit(1);
               printf("this is the text video mode (DOS video mode 3)...");
               getch();
               videomodeset(vmode);
               exit(0);
            }











                                                                        157







          SCROLLDN

            PROTOTYPE

            extern void far scrolldn (int x1, int y1, int x2, int y2, int
            num, int colr)

            INPUT

            x1, y1 - top left corner of block
            x2, y2 - bottom right corner of block
            num - number of pixels to shift
            colr - index to color in current palette

            OUTPUT

            no value returned

            USAGE

            SCROLLDN shifts the contents of the box described by (x1, y1)
            - (x2, y2) down by the number of pixels specified by num.  The
            empty pixels created at the top of the box are filled with
            colr.  The pixels that are shifted out of the box are lost.
            SCROLLDN enforces x2 x1 and y2y1.  When placed within a loop,
            SCROLLDN will create a scrolling effect.

            SEE ALSO

            SCROLLLT, SCROLLRT, SCROLLUP

            EXAMPLE

            /*
             * scroll some text down
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode, i;

               vmode = videomodeget();
               if ( !whichvga() || (whichmem() < 512))
                 exit(1);
               res640();
               drwbox (1,10,0,0,100,100);
               drwstring(1,7,0,"text text",20,43);
               for(i=0;i<40;i++)
               {
                 scrolldn(1,1,99,99,1,0);


                                                                        158







                 sdelay(2);
               }
               getch();
               videomodeset(vmode);
            }



















































                                                                        159







          SCROLLLT

            PROTOTYPE

            extern void far scrolllt (int x1, int y1, int x2, int y2, int
            num, int colr)

            INPUT

            x1, y1 - top left corner of block
            x2, y2 - bottom right corner of block
            num - number of pixels to shift
            colr - index to color in current palette

            OUTPUT

            no value returned

            USAGE

            SCROLLLT shifts the contents of the box described by (x1, y1)
            - (x2, y2) down by the number of pixels specified by num.  The
            empty pixels created at the right of the box are filled with
            colr.  The pixels that are shifted out of the box are lost.
            SCROLLLT enforces x2 x1 and y2y1.  When placed within a loop,
            SCROLLRT will create a scrolling effect.

            SEE ALSO

            SCROLLDN, SCROLLRT, SCROLLUP

            EXAMPLE

            /*
             * scroll some text left
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode, i;

               vmode = videomodeget();
               if ( !whichvga() || (whichmem() < 512))
                 exit(1);
               res640();
               drwbox (1,10,0,0,100,100);
               drwstring(1,7,0,"text text",20,43);
               for(i=0;i<40;i++)
               {
                 scrolllt(1,1,99,99,1,0);


                                                                        160







                 sdelay(2);
               }
               getch();
               videomodeset(vmode);
            }



















































                                                                        161







          SCROLLRT

            PROTOTYPE

            extern void far scrollrt (int x1, int y1, int x2, int y2, int
            num, int colr)

            INPUT

            x1, y1 - top left corner of block
            x2, y2 - bottom right corner of block
            num - number of pixels to shift
            colr - index to color in current palette

            OUTPUT

            no value returned

            USAGE

            SCROLLRT shifts the contents of the box described by (x1, y1)
            - (x2, y2) down by the number of pixels specified by num.  The
            empty pixels created at the left of the box are filled with
            colr.  The pixels that are shifted out of the box are lost.
            SCROLLRT enforces x2 x1 and y2y1.  When placed within a loop,
            SCROLLRT will create a scrolling effect.

            SEE ALSO

            SCROLLDN, SCROLLLT, SCROLLUP

            EXAMPLE

            /*
             * scroll some text right
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode, i;

               vmode = videomodeget();
               if ( !whichvga() || (whichmem() < 512))
                 exit(1);
               res640();
               drwbox (1,10,0,0,100,100);
               drwstring(1,7,0,"text text",20,43);
               for(i=0;i<40;i++)
               {
                 scrollrt(1,1,99,99,1,0);


                                                                        162







                 sdelay(2);
               }
               getch();
               videomodeset(vmode);
            }



















































                                                                        163







          SCROLLUP

            PROTOTYPE

            extern void far scrollup (int x1, int y1, int x2, int y2, int
            num, int colr)

            INPUT

            x1, y1 - top left corner of block
            x2, y2 - bottom right corner of block
            num - number of pixels to shift
            colr - index to color in current palette

            OUTPUT

            no value returned

            USAGE

            SCROLLUP shifts the contents of the box described by (x1, y1)
            - (x2, y2) down by the number of pixels specified by num.  The
            empty pixels created at the bottom of the box are filled with
            colr.  The pixels that are shifted out of the box are lost.
            SCROLLUP enforces x2 x1 and y2y1.  When placed within a loop,
            SCROLLUP will create a scrolling effect.

            SEE ALSO

            SCROLLDN, SCROLLLT, SCROLLRT

            EXAMPLE

            /*
             * scroll some text up
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode, i;

               vmode = videomodeget();
               if ( !whichvga() || (whichmem() < 512))
                 exit(1);
               res640();
               drwbox (1,10,0,0,100,100);
               drwstring(1,7,0,"text text",20,43);
               for(i=0;i<40;i++)
               {
                 scrollup(1,1,99,99,1,0);


                                                                        164







                 sdelay(2);
               }
               getch();
               videomodeset(vmode);
            }



















































                                                                        165







          SDELAY

            PROTOTYPE

            extern void far sdelay (int count)

            INPUT

            count - number of vertical syncs to wait

            OUTPUT

            no value returned

            USAGE

            SDELAY pauses execution of the program for a period of time
            specified by count.  This delay remains approximately constant
            on all machines by using the vertical sync timer of the VGA
            graphics card which is about 60 - 70 Hz.

            EXAMPLE

            /*
             * make a delay of about 3 seconds long
             */

            #include <stdlib.h>
            #include <conio.h>
            #include <time.h>
            #include "svgacc.h"

            void main(void)
            {
               time_t starttime;
               time_t endtime;
               printf("ok...stating delay...should be about 3 seconds...");
               time( &starttime);
               sdelay(195);
               time( &endtime);
               printf("total time was: %d seconds...", endtime-starttime);
               exit(0);
            }













                                                                        166







          SETCARD

            PROTOTYPE

            extern void far setcard (VGAChipset chip, int mem)

            INPUT

            chip - code for SVGA chip type
            mem - amount of video memory installed

            OUTPUT

            no value returned

            USAGE

            WARNING:  USING SETCARD IMPROPERLY MAY CAUSE A SYSTEM FAILURE
            OR DAMAGE.
            SETCARD sets the card type and installed video memory.  It can
            be used instead of the WHICHVGA function.  However, specifying
            an incorrect chip type or installed video memory may cause
            unpredictable results not excluding damage to the SVGA card
            and/or monitor.  Extreme caution is advised when using this
            function.  It is recommended that this function only be used
            when it is suspected that the identification process in
            WHICHVGA failed.  Be absolutely certain that the chip type
            specified is the actual chip type installed in the computer.
            Mem should be a value of 256, 512 or 1024 representing the
            kilobytes of video memory installed.  Use the following table
            to identify chip types:

          1  Acumos AVGA2/3 SuperVGA
          2  ATI Technologies 18/28/38/68800
             SuperVGA
          3  Ahead V5000 ver A SuperVGA
          4  Ahead V5000 ver B SuperVGA
          5  Chips and Technologies 82C45x SuperVGA
          6  Cirrus Logic CL-GD 5xx, 6xx, 28xx,
             54xx, 62xx SuperVGA
          7  Everex Micro Enhancer Ev236/6xx
             SuperVGA
          8  Genoa 61/62/63/64/6600 SuperVGA
          9  NCR 77C21/22/22E/22E+ SuperVGA
          10 Oak Technologies OTI-037C/067/077/087
             SuperVGA
          11 Paradise/Western Digital PVGA1A,
             WD90C00/1x/2x/3x SuperVGA
          12 Realtek RT3106 SuperVGA
          13 Trident 8800CS, 8900B/C/CL/CX, 90x0
             SuperVGA
          14 Tseng Labs ET3000-AX/BX/BP SuperVGA
          15 Tseng Labs ET4000/W32/W32I SuperVGA
          16 VESA compatible SuperVGA


                                                                        167







          17 Video 7 HT-208/16 SuperVGA
          18 Avance Logic AL2101 SuperVGA
          19 MXIC MX68000/10 SuperVGA
          20 Primus P2000 SuperVGA

            SEE ALSO

            WHICHVGA

            EXAMPLE

            /*
            !WARNING!WARNING!WARNING!WARNING!WARNING!WARNING!WARNING!WARNI
            NG!  */
            /*                                                        */
            /* USE THE "SETCARD" FUNCTION CAREFULLY. IT WORKS AROUND
            "WHICHVGA".  */
            /* IMPROPER USE (I.E. SETTING THE CARD ID AND MEMORY TO
            SOMETHING    */
            /* THAT IS NOT VALID) MIGHT DAMAGE YOUR VIDEO CARD/VIDEO
            MONITOR OR   */
            /* CAUSE UNPREDICTABLE RESULTS. IT IS PROVIDED AS A METHOD TO
            FIND */
            /* FAULTS IN THE VIDEO CARD/CHIP ID PROCESS.
               */
            /*                                                        */
            /*
            !WARNING!WARNING!WARNING!WARNING!WARNING!WARNING!WARNING!WARNI
            NG!  */



























                                                                        168







          SETVIEW

            PROTOTYPE

            extern void far setview (int x1, int y1, int x2, int y2)

            INPUT

            x1, y1 - top, left corner of view port
            x2, y2 - bottom, right corner of view port

            OUTPUT

            no value returned

            USAGE

            SETVIEW defines a viewport for clipping output on the screen.
            Nothing can be drawn outside of the currently defined
            viewport.  The RES### functions set the viewport to the full
            screen.  The restrictions on X1, Y1, X2 and Y2 are as follows:

            0   X1 < X2  (screen width)
            0   Y1 < Y2  (32767, effectively unbounded)

            SEE ALSO

            RES320, RES640, RES640L, RES800, RES1024, RES1280

            EXAMPLE

            /*
             * draws a lines clipped to a view port
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"
            #define randnum(size) (rand() % (int)(size))

            void main(void)
            {
               int vmode, i, x1, y1, x2, y2;

               vmode = videomodeget();
               if ( !whichvga() || (whichmem() < 512))
                 exit(1);
               res640();
               drwbox(1,15,101,101,538,378);
               setview(101,101,538,378);
               for(i=0;i<300;i++) {
                 x1 = randnum(640);
                 y1 = randnum(480);
                 x2 = randnum(640);


                                                                        169







                 y2 = randnum(480);
                 drwline(1,10,x1,y1,x2,y2);
               }
               getch();
               videomodeset(vmode);
               exit(0);
            }

















































                                                                        170







          SPRITECOLLDETECT

            PROTOTYPE

            extern int far spritecolldetect (int transcolr, int x1, int
            y1, int x2, int y2, RasterBlock far *sprite1, RasterBlock far
            *sprite2)

            INPUT

            transcolr - index to color in current palette
            x1, y1 - location of top, left corner of sprite number 1
            x2, y2 - location of top, left corner of sprite number 2
            sprite1 - sprite number 1
            sprite2 - sprite number 2

            OUTPUT

            SPRITECOLLDETECT returns the collision status of the two
            sprites.

            USAGE

            SPRITECOLLDETECT is used in sprite graphics or animation to
            report the collision status between two sprites.  Sprite1
            contains the first sprite which should have been previously
            defined by BLKGET or similar function.  Sprite2, likewise,
            contains the second sprite.  The top, left corner of the first
            and second sprites' locations are specified by x1, y1 and x2,
            y2, respectively.

            SPRITECOLLDETECT will return a zero if the sprites are not
            colliding and the blocks are not overlapping.  The return will
            be one if the blocks overlap, but the sprites are not
            colliding.  A return value of two indicates that the sprites
            have at least one overlapping pixel and are, therefore,
            colliding.

            SEE ALSO

            BLKGET, BLKPUT, GETLASTSTRING, SPRITEGAP, SPRITEGET, SPRITEPUT

            EXAMPLE

            /*
             * shows how spritecolldetect works
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {


                                                                        171







               int vmode, ret, i, x1, y1, x2, y2;
               char text[70];

               RasterBlock *sprite1data, *sprite2data;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               res320();
               x1 = 0;
               y1 = 0;
               x2 = 48;
               y2 = 48;
               drwline(1,8,x1,y1,x2,y1);
               drwline(1,8,x2,y1,x2,y2);
               drwline(1,8,x2,y2,x1,y2);
               drwline(1,8,x1,y2,x1,y1);
               fillarea(x1+1,y1+1,8,8);
               drwellipse(1,10,((x2-x1)/2+x1),((y2-y1)/2+y1),(x2-x1)/2,(y2-
            y1)/2);
               sprite1data = (RasterBlock *)malloc((x2-x1+1)*(y2-y1+1)+4);
               blkget(x1,y1,x2,y2,sprite1data);
               blkput(2,x1,y1,sprite1data);
               x1 = 0;
               y1 = 0;
               x2 = 24;
               y2 = 24;
               drwline(1,8,x1,y1,x2,y1);
               drwline(1,8,x2,y1,x2,y2);
               drwline(1,8,x2,y2,x1,y2);
               drwline(1,8,x1,y2,x1,y1);
               fillarea(x1+1,y1+1,8,8);
               drwline(1,10,x1,y1,x2,y2);
               drwline(1,10,x2,y1,x1,y2);
               sprite2data = (RasterBlock *)malloc((x2-x1+1)*(y2-y1+1)+4);
               blkget(x1,y1,x2,y2,sprite2data);
               blkput(2,x1,y1,sprite2data);
               x1=90;
               y1=90;
               blkput(2,x1,y1,sprite1data);
               for(i=30;i<150;i++)
               {
                 blkput(2,i,i,sprite2data);
                 ret =
            spritecolldetect(8,x1,y1,i,i,sprite1data,sprite2data);
                 sprintf(text,"the return value is: %d",ret);
                 drwstring(1,7,0,text,0,0);
                 getch();
                 blkput(2,i,i,sprite2data);
               }
               videomodeset(vmode);
               exit(0);
            }



                                                                        172







          SPRITEGAP

            PROTOTYPE

            extern void far spritegap (int transcolr, int x, int y,
            RasterBlock far *sprite, RasterBlock far *spritebkgnd)

            INPUT

            transcolr - index to color in current palette
            x, y - top, left corner of block
            sprite- the sprite to place on screen

            OUTPUT

            no value returned
            spritebkgnd - sprite background

            USAGE

            SPRITEGAP ("Sprite-Get-And-Put") is used in sprite graphics or
            animation to retrieve a sprite's background and then display
            the sprite.  Sprite contains the sprite which should have been
            previously defined by BLKGET or similar function such as
            GETLASTSTRING.  Transcolr is the transparent colr assumed in
            sprite.  Spritebkgnd, a pointer to a RasterBlock structure the
            same size as the sprite, will receive the sprite's background.
            The top, left corner of the sprite's location is specified by
            x, y.

            SEE ALSO

            BLKGET, BLKPUT, GETLASTSTRING, SPRITECOLLDETECT, SPRITEGET,
            SPRITEPUT

            EXAMPLE

            /*
             * Show spritegap
             */

            #include <stdlib.h>
            #include <math.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;
               int i, j, colr, xinc, yinc, x1, y1, x2, y2, cnt, cntx, cnty,
            rot;
               RasterBlock *gfxblk, *gfxblk2, *spritebkgnd;

               vmode = videomodeget();


                                                                        173







               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               if ( !res640() )
                 exit(1);
               xinc = maxx/20;
               yinc = maxy/20;
               x1 = maxx/2-xinc;
               y1 = maxy/2-yinc;
               x2 = maxx/2+xinc;
               y2 = maxy/2+yinc;
               i = (x2-x1+1)*(y2-y1+1)+4;
               gfxblk = (RasterBlock *)malloc(i);
               if (!gfxblk) {
                 restext();
                 printf("ERROR: Allocating memory for gfxblk: %d
            bytes\n",i);
                 exit(1);
               }
               colr = 1;
               for(i=0;i<=maxx/2;i++) {
                 drwcircle(1,colr,maxx/4+i,maxy/2,maxy/5);
                 colr+=1;
                 if(colr>15)
                    colr = 1;
               }
               drwbox(1,0,x1,y1,x2,y2);
               blkget(x1,y1,x2,y2,gfxblk);
               cntx = (x2-x1) / 2 + x1;
               cnty = (y2-y1) / 2 + y1;
               fillarea(x1+2,y1+2,0,0);
               i = blkrotatesize(45,gfxblk);
               spritebkgnd = (RasterBlock *)malloc(i);
               if (!spritebkgnd) {
                 restext();
                 printf("ERROR: Allocating memory for spritebkgnd: %d
            bytes\n",i);
                 exit(1);
               }
               gfxblk2 = (RasterBlock *)malloc(i);
               if (!gfxblk2) {
                 restext();
                 printf("ERROR: Allocating memory for gfxblk2: %d
            bytes\n",i);
                 exit(1);
               }
               blkget(x1,y1,x2,y2,spritebkgnd);
               setview(0,64,maxx,maxy);
               for(i=0;i<=360;i+=3) {
                 rot = blkrotate(i,1,gfxblk,gfxblk2);
                 spriteput(SET,1,cntx-(spritebkgnd->width)/2,cnty-
            (spritebkgnd->height)/2,spritebkgnd);



                                                                        174







                 spritegap(1,cntx-(gfxblk2->width)/2,cnty-(gfxblk2-
            >height)/2,gfxblk2,spritebkgnd);
                 sdelay(3);
               }
               spriteput(SET,1,cntx-(spritebkgnd->width)/2,cnty-
            (spritebkgnd->height)/2,spritebkgnd);
               blkput(SET,x1,y1,(RasterBlock *)gfxblk);
               getch();
               videomodeset(vmode);
               exit(0);
            }













































                                                                        175







          SPRITEGET

            PROTOTYPE

            extern void far spriteget (int transcolr, int x, int y,
            RasterBlock far *sprite, RasterBlock far *spritebkgnd)

            INPUT

            transcolr - index to color in current palette
            x, y - top, left corner of block
            sprite - sprite to use as pattern

            OUTPUT

            no value returned
            spritebkgnd - sprite background

            USAGE

            SPRITEGET is used in sprite graphics or animation to retrieve
            the background for a sprite, normally just before using
            SPRITEPUT.  Sprite contains the sprite which should have been
            previously defined by BLKGET or similar function.  Transcolr
            is the transparent color assumed in the sprite.  Spritebkgnd,
            a pointer to a RasterBlock structure the same size as the
            sprite, will receive the sprite's background.  The top, left
            corner of the sprite's location is specified by x, y.

            SEE ALSO

            BLKGET, BLKPUT, GETLASTSTRING, SPRITECOLLDETECT, SPRITEGAP,
            SPRITEPUT

            EXAMPLE

            /*
             * Show spriteget
             */

            #include <stdlib.h>
            #include <math.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode, i, j, colr, xinc, yinc, x1, y1, x2, y2, cntx,
            cnty, rot;
               RasterBlock *gfxblk, *gfxblk2, *spritebkgnd;
               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)


                                                                        176







                 exit(1);
               if ( !res640() )
                 exit(1);
               xinc = maxx/20;
               yinc = maxy/20;
               x1 = maxx/2-xinc;
               y1 = maxy/2-yinc;
               x2 = maxx/2+xinc;
               y2 = maxy/2+yinc;
               i = (x2-x1+1)*(y2-y1+1)+4;
               gfxblk = (RasterBlock *)malloc(i);
               if (!gfxblk) {
                 restext();
                 printf("ERROR: Allocating memory for gfxblk: %d
            bytes\n",i);
                 exit(1);
               }
               colr = 1;
               for(i=0;i<=maxx/2;i++) {
                 drwcircle(1,colr,maxx/4+i,maxy/2,maxy/5);
                 colr+=1;
                 if(colr>15)
                    colr = 1;
               }
               drwbox(1,0,x1,y1,x2,y2);
               blkget(x1,y1,x2,y2,gfxblk);
               cntx = (x2-x1) / 2 + x1;
               cnty = (y2-y1) / 2 + y1;
               fillarea(x1+2,y1+2,0,0);
               i = blkrotatesize(45,gfxblk);
               spritebkgnd = (RasterBlock *)malloc(i);
               if (!spritebkgnd) {
                 restext();
                 printf("ERROR: Allocating memory for spritebkgnd: %d
            bytes\n",i);
                 exit(1);
               }
               gfxblk2 = (RasterBlock *)malloc(i);
               if (!gfxblk2) {
                 restext();
                 printf("ERROR: Allocating memory for gfxblk2: %d
            bytes\n",i);
                 exit(1);
               }
               blkget(x1,y1,x2,y2,spritebkgnd);
               setview(0,64,maxx,maxy);
               for(i=0;i<=360;i+=3) {
                 rot = blkrotate(i,1,gfxblk,gfxblk2);
                 spriteput(SET,1,cntx-(spritebkgnd->width)/2,cnty-
            (spritebkgnd->height)/2,spritebkgnd);
                 spriteget(1,cntx-(gfxblk2->width)/2,cnty-(gfxblk2-
            >height)/2,gfxblk2,spritebkgnd);
                 spriteput(SET,1,cntx-(gfxblk2->width)/2,cnty-(gfxblk2-
            >height)/2,gfxblk2);


                                                                        177







                 sdelay(3);
               }
               spriteput(SET,1,cntx-(spritebkgnd->width)/2,cnty-
            (spritebkgnd->height)/2,spritebkgnd);
               blkput(SET,x1,y1,(RasterBlock *)gfxblk);
               getch();
               videomodeset(vmode);
               exit(0);
            }















































                                                                        178







          SPRITEPUT

            PROTOTYPE

            extern void far spriteput (PixelMode mode, int transcolr, int
            x, int y, RasterBlock far *sprite)

            INPUT

            mode - pixel write mode
            transcolr - index to color in current palette
            x, y - top, left corner of block
            sprite- sprite to place on screen

            OUTPUT

            no value returned

            USAGE

            SPRITEPUT is used in sprite graphics or animation to display a
            sprite or, more commonly, its background.  Sprite contains the
            sprite which should have been previously defined by BLKGET,
            SPRITEGAP or SPRITEGET.  Transcolr is the transparent color
            assumed in sprite.  The top, left corner of the sprite's
            location is specified by x, y.

            SEE ALSO

            BLKGET, BLKPUT, GETLASTSTRING, SPRITECOLLDETECT, SPRITEGAP,
            SPRITEGET

            EXAMPLE

            See SPRITEGET





















                                                                        179







          VIDEOMODEGET

            PROTOTYPE

            extern int far videomodeget (void)

            INPUT

            no input parameters

            OUTPUT

            the current video mode

            USAGE

            VIDEOMODEGET returns the current video mode.  This function is
            best used to retrieve the video mode being used when a program
            begins.  When the program ends, this video mode can then be
            restored using VIDEOMODESET.

            SEE ALSO

            RES320, RES640, RES640L, RES800, RES1024, RES1280, RESTEXT,
            VIDEOMODESET

            EXAMPLE

            /*
             * save the current video mode, enable 640x480x256, and reset
            the video mode
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;

               vmode = videomodeget();
               if ( !whichvga() )
                 exit(1);
               if ( whichmem() < 512)
                 exit(1);
               res640();
               videomodeset(vmode);
               printf("we are back!");
               getch();
               exit(0);
            }




                                                                        180







          VIDEOMODESET

            PROTOTYPE

            extern void far videomodeset (int videomode)

            INPUT

            mode - number of video mode

            OUTPUT

            no value returned

            USAGE

            VIDEOMODESET sets the video mode specified by mode.  This
            function is best used at the end of a program to restore the
            video mode to the mode in use when the program began.  The
            program should retrieve the video mode at the beginning by
            using VIDEOMODEGET.

            SEE ALSO

            RES320, RES640, RES640L, RES800, RES1024, RES1280, RESTEXT,
            VIDEOMODEGET

            EXAMPLE

            See VIDEMODEGET


























                                                                        181







          VIDEOOFF

            PROTOTYPE

            extern void far videooff (void)

            INPUT

            no input parameters

            OUTPUT

            no value returned

            USAGE

            VIDEOOFF turns the output display off.  Graphics may still be
            drawn to the screen.  However, the computer's monitor will
            display nothing and appear black.  This function can be used
            to hide graphics being drawn by initially using VIDEOOFF and
            then later calling VIDEOON.

            SEE ALSO

            VIDEOON

            EXAMPLE

            /*
             * disable the video for about 3 seconds, then enable it
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;

               printf("press a key to disable video for 3 seconds...");
               getch();
               videooff();
               sdelay(195);
               videoon();
               videomodeset(vmode);
               printf("we are back!");
               getch();
               exit(0);
            }






                                                                        182







          VIDEOON

            PROTOTYPE

            extern void far videoon (void)

            INPUT

            no input parameters

            OUTPUT

            no value returned

            USAGE

            VIDEOON turns the display on.  All graphics that were drawn
            while the display was off are now visible.  This function can
            be used to hide graphics being drawn by initially using
            VIDEOOFF and then later calling VIDEOON.

            SEE ALSO

            VIDEOOFF

            EXAMPLE

            See VIDEOOFF




























                                                                        183







          WHICHCPU

            PROTOTYPE

            extern int far whichcpu (void)

            INPUT

            no input parameters

            OUTPUT

            processor type

            USAGE

            WHICHCPU returns the computer's processor type as 86, 286,
            386, 486 or 586.  This function should be called by any
            program using this library's routines to insure that the
            computer is at least 386 compatible or better.

            SEE ALSO

            WHICHJOYSTICK, WHICHMOUSE, WHICHVGA

            EXAMPLE

            /*
             * id the microprocessor
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode;
               int cpu;

               cpu = whichcpu();
               printf("Microprocessor is identified as an 80%d.\n", cpu);
               getch();
               exit(0);
            }











                                                                        184







          WHICHJOYSTICK

            PROTOTYPE

            extern int far whichjoystick (void)

            INPUT

            no input parameters

            OUTPUT

            available joystick support

            USAGE

            WHICHJOYSTICK returns the joystick support available on the
            computer.  This function should be called prior to use of the
            joysticks to verify that joysticks are available.  If the
            function returns a -1, there is no joystick port present or no
            BIOS support for a joystick.  Joystick A is bit 1 and B is bit
            2.  Therefore, a return value of 1 means joystick A is
            available, a value of 2 means B is available and a value of 3
            means both are available.  If no bits are set, there are no
            joysticks present.

            SEE ALSO

            JOYSTICKINFO, WHICHCPU, WHICHMOUSE, WHICHVGA

            EXAMPLE

            /* id any joysticks */
            #include <stdlib.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode, joystick;

               joystick = whichjoystick();
               switch (joystick) {
                 case -1:
                    printf("No joystick port detected or no joystick BIOS
            support present.\n\n");
                    break;
                 case 0:
                    printf("No joystick detected\n\n");
                    break;
                 case 1:
                    printf("Joystick A is present and available.\n\n");
                    break;
                 case 2:
                    printf("Joystick B is present and available.\n\n");


                                                                        185







                    break;
                 case 3:
                    printf("Both Joystick A and Joystick B are
            present.\n\n");
                    break;
               }
            }

















































                                                                        186







          WHICHMEM

            PROTOTYPE

            extern int far whichmem (void)

            INPUT

            no input parameters

            OUTPUT

            installed video memory in kilobytes

            USAGE

            WHICHMEM returns the amount of installed video memory as
            previously determined by WHICHVGA.  WHICHVGA should be called
            prior to WHICHMEM.  This function should be called prior to
            any of the RES### functions to verify that there is enough
            memory to support the desired resolution.  If SETCARD was used
            to set the video card and memory, WHICHMEM will return the
            amount of memory as defined by SETCARD.

            SEE ALSO

            RES320, RES640, RES640L, RES800, RES1024, RES1280, SETCARD,
            WHICHVGA

            EXAMPLE

            /*
             * id the video memory
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int vmode, vga, mem;

               vga = whichvga();
               mem = whichmem();
               printf("Installed video memory is %d k.\n", mem);
               getch();
               exit(0);
            }







                                                                        187







          WHICHMOUSE

            PROTOTYPE

            extern int far whichmouse (void)

            INPUT

            no input parameters

            OUTPUT

            number of buttons on mouse

            USAGE

            WHICHMOUSE returns a value indicating whether a Microsoft
            compatible mouse is available.  If the function returns a 0,
            no mouse is available.  A non zero value indicates a mouse and
            Microsoft compatible driver are installed and gives the number
            of buttons (2 or 3) available.

            SEE ALSO

            MOUSEINFO, WHICHCPU, WHICHJOYSTICK, WHICHVGA

            EXAMPLE

            See MOUSEINFO



























                                                                        188







          WHICHVGA

            PROTOTYPE

            extern VGAChipset far whichvga (void)

            INPUT

            no input parameters

            OUTPUT

            WHICHVGA returns a code identifying the video card.

            USAGE

            WHICHVGA identifies the video card installed and the amount of
            video memory.  In addition this function sets up the default
            font and mouse cursor.  This function must be called before
            any other graphics function.  The code returned identifies the
            video card according to the following table:

          1  Acumos AVGA2/3 SuperVGA
          2  ATI Technologies 18/28/38/68800
             SuperVGA
          3  Ahead V5000 ver A SuperVGA
          4  Ahead V5000 ver B SuperVGA
          5  Chips and Technologies 82C45x SuperVGA
          6  Cirrus Logic CL-GD 5xx, 6xx, 28xx,
             54xx, 62xx SuperVGA
          7  Everex Micro Enhancer Ev236/6xx
             SuperVGA
          8  Genoa 61/62/63/64/6600 SuperVGA
          9  NCR 77C21/22/22E/22E+ SuperVGA
          10 Oak Technologies OTI-037C/067/077/087
             SuperVGA
          11 Paradise/Western Digital PVGA1A,
             WD90C00/1x/2x/3x SuperVGA
          12 Realtek RT3106 SuperVGA
          13 Trident 8800CS, 8900B/C/CL/CX, 90x0
             SuperVGA
          14 Tseng Labs ET3000-AX/BX/BP SuperVGA
          15 Tseng Labs ET4000/W32/W32I SuperVGA
          16 VESA compatible SuperVGA
          17 Video 7 HT-208/16 SuperVGA
          18 Avance Logic AL2101 SuperVGA
          19 MXIC MX68000/10 SuperVGA
          20 Primus P2000 SuperVGA

            Any value returned not found on this table represents an
            unidentified video card.

            No graphics functions should be called unless the video card
            is properly identified.


                                                                        189








            SEE ALSO

            SETCARD, WHICHCPU, WHICHJOYSTICK, WHICHMOUSE, WHICHMEM

            EXAMPLE

            /*
             * id the svga
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {

            char buf[40];

            switch(whichvga()) {
               case ACUMOS:
                 sprintf(buf,"Acumos AVGA2/3 SuperVGA");
                 break;
               case ATI:
                 sprintf(buf,"ATI Technologies 18/28/38/68800 SuperVGA");
                 break;
               case AHEADA:
                 sprintf(buf,"Ahead V5000 Ver A SuperVGA");
                 break;
               case AHEADB:
                 sprintf(buf,"Ahead V5000 Ver B SuperVGA");
                 break;
               case CHIPSTECH:
                 sprintf(buf,"Chips and Technologies 82C450/1/2/3/5/6/7
          SuperVGA");
                 break;
               case CIRRUS:
                 sprintf(buf,"Cirrus Logic CL-GD 5xx,6xx,28xx,54xx,62xx
          SuperVGA");
                 break;
               case EVEREX:
                 sprintf(buf,"Everex EV236/6xx Micro Enhancer SuperVGA");
                 break;
               case GENOA:
                 sprintf(buf,"Genoa 61/62/63/64/6600 SuperVGA");
                 break;
               case NCR:
                 sprintf(buf,"NCR 77C21/22/22E/22E+ SuperVGA");
                 break;
               case OAKTECH:
                 sprintf(buf,"Oak Technologies OTI-037/67/77/87C
          SuperVGA");
                 break;


                                                                        190







               case PARADISE:
                 sprintf(buf,"Paradise/Western Digital
          PVGA1A,WD90C00/1x/2x/3x SuperVGA");
                 break;
               case REALTEK:
                 sprintf(buf,"Realtek RT3106 SuperVGA");
                 break;
               case TRIDENT:
                 sprintf(buf,"Trident 8800CS,8900B/C/CL/CX,90x0
          SuperVGA");
                 break;
               case TSENG3:
                 sprintf(buf,"Tseng Labs ET3000-AX/BX/BP SuperVGA");
                 break;
               case TSENG4:
                 sprintf(buf,"Tseng Labs ET4000/W32/W32I SuperVGA");
                 break;
               case VESA:
                 sprintf(buf,"VESA compatible SuperVGA");
                 break;
               case VIDEO7:
                 sprintf(buf,"Video 7 HT-208/16 SuperVGA");
                 break;
               case AVANCE:
                 sprintf(buf,"Avance Logic AL2101 SuperVGA");
                 break;
               case MXIC:
                 sprintf(buf,"MXIC MX68000/10 SuperVGA");
                 break;
               case PRIMUS:
                 sprintf(buf,"Primus P2000 SuperVGA");
                 break;
               default:
                 printf("Sorry, unable to identify video card or it is not
          a SuperVGA video adapter.\n");
                 exit(0);
            }
            printf("Video card/chip is identified as %s.\n",&buf);
            exit(0);
          }
















                                                                        191







          WHICHXMS

            PROTOTYPE

            extern int far whichxms (unsigned int far *xmskbytesavail,
            unsigned int far *xmshandlesavail)

            INPUT

            no input parameters

            OUTPUT

            WHICHXMS returns a 1 if extended memory support is detected, 0
            otherwise.
            xmskbytesavail - number of free kilobytes in extended memory
            xmshandlesavail - number of available free handles

            USAGE

            WHICHXMS detects the existence of extended memory support and
            sets up the library function calls.  This function must be
            called before any other extended memory functions.  WHICHXMS
            also returns the number of free kilobytes of extended memory
            and the number of available handles.  The number of available
            handles is limited, normally to 32.  This limit can be
            modified by changing the extended memory driver (Microsoft's
            HIMEM.SYS is the most common) command line in the CONFIG.SYS
            file.

            SEE ALSO

            XMSALLOCATE, XMSCOPY, XMSERROR, XMSFREE, XMSGET, XMSPUT

            EXAMPLE

            /*
             * show what xms memory is available
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int er, mem, handles;

               if ( whichxms(&mem,&handles) ) {
                 printf("an active xms memory manager was found!\n");
                 printf("a total of %d kb of xms memory
            available...\n",mem);
                 printf("a total of %d xms memory handles
            available...\n",handles);


                                                                        192







                 printf(" \n");
                 if ((mem < 1) || (handles < 1)) {
                    printf("sorry...there is either no free xms or\n");
                    printf("no free handles\n");
                    printf(" \n");
                    printf("xms support not available...\n");
                    exit(1);
                 }
                 else {
                 printf(" \n");
                 printf("xms support is ready and available!\n");
                 exit(1);
                 }
               }
               else {
                 printf("sorry...no active xms memory manager
            found...\n");
                 printf("make sure you have an xms memory manager\n");
                 printf("(such as HIMEM.SYS) loaded\n");
                 printf(" \n");
                 printf("xms support not available...\n");
                 exit(1);
               }

               exit(0);
            }






























                                                                        193







          XMSALLOCATE

            PROTOTYPE

            extern int far xmsallocate (unsigned int reqkbytes)

            INPUT

            reqkbytes - requested number of kilobytes of extended memory

            OUTPUT

            XMSALLOCATE returns the assigned memory handle if the
            allocation is successful, 0 otherwise.

            USAGE

            XMSALLOCATE attempts to allocate the requested number of
            kilobytes in extended memory.  If successful, the function
            returns the handle of the new memory block.  If the function
            returns zero, then the allocation was unsuccessful; check
            XMSERROR for error codes.

            All allocated blocks must be freed using XMSFREE before a
            program terminates or the memory is lost until the machine is
            rebooted.  Simply exiting a program will not free allocated
            extended memory blocks.

            SEE ALSO

            WHICHXMS, XMSCOPY, XMSERROR, XMSFREE, XMSGET, XMSPUT,
            XMSSCREENGET, XMSSCREENPUT

            EXAMPLE

            See XMSCOPY




















                                                                        194







          XMSBLKGET

            PROTOTYPE

            extern int far xmsblkget (int x1, int y1, int x2, int y2)

            INPUT

            x1, y1 - top left corner of block
            x2, y2 - bottom right corner of block

            OUTPUT

            Used as a function, XMSBLKGET returns the assigned XMS memory
            handle if successful, 0 otherwise.

            USAGE

            XMSBLKGET stores the pixel data contained within the block
            defined by (x1, y1)-(x2, y2) in extended memory.  A minimum of
            32k of XMS memory will be allocated regardless of the size of
            the graphics  block.  Note that XMSBLKGET enforces x2>x1 and
            y2>y1.  Also, the coordinates must be valid on the screen at
            the current resolution.  The bitmap is stored such that the
            first integer in the allocated XMS block is the width and the
            second integer is the height.  These are followed by a long
            integer (4 bytes) that specifies the total size of the
            allocated XMS block.  The remaining bytes are the bitmap
            raster data stored by rows starting at the top of the block.
            If the function was unsuccessful, check XMSERROR for error
            codes.

            All allocated XMS blocks must be freed using XMSFREE before a
            program terminates or the memory is lost until the machine is
            rebooted.  Simply exiting a program will not free allocated
            extended memory blocks.

            SEE ALSO

            BLKGET, BLKPUT, XMSBLKPUT, XMSERROR, XMSFREE, XMSSCREENGET,
            XMSSCREENPUT

            EXAMPLE

            /*
             * this will copy a larger graphics block (about 80k)
             * from one part of the screen to another using xms memory
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"
            #define randnum(size) (rand() % (int)(size))



                                                                        195







            void main(void)
            {
               int i, handle, er, mem, handles,x1,y1,x2,y2,colr;

               /* make sure xms is ready and available */
               if ( whichxms(&mem,&handles) ) {
                 if ((mem < 1) || (handles < 1)) {
                    printf("sorry...there is either no free xms or\n");
                    printf("no free handles\n");
                    exit(1);
                 }
               }
               else {
                 printf("sorry...no active xms memory manager
            found...\n");
                 printf("make sure you have an xms memory manager\n");
                 printf("(such as HIMEM.SYS) loaded\n");
                 exit(1);
               }

               if ( !whichvga() )
                 exit(1);
               if ( !res640() )
                 exit(1);
               drwfillbox(SET,10,0,0,200,400);
               for(i=0;i<=200;i++)
               {
                 x1 = randnum(200);
                 y1 = randnum(400);
                 x2 = randnum(200);
                 y2 = randnum(400);
                 colr = randnum(16);
                 drwline(1,colr,x1,y1,x2,y2);
               }
               drwbox(SET,15,0,0,200,400);
               handle = xmsblkget(0,0,200,400);
               if ( !handle ) {
                 printf("opps there is some error...unable to allocate
            xms...\n");
                 printf("error # %d\n",xmserror());
                 er = xmsfree(handle);
                 exit(1);
               }
               er = xmsblkput(SET,175,75,handle);
               er = xmsfree(handle);

               getch();
               restext();
               exit(0);
            }






                                                                        196







          XMSBLKPUT

            PROTOTYPE

            extern int far xmsblkput (int mode, int x, int y, int
            srcxmshandle)

            INPUT

            mode - pixel write mode (SET=1, XOR=2, OR=3, AND=4)
            x, y - location for top left corner of block
            srcxmshandle - handle of source extended memory block

            OUTPUT

            Used as a function, XMSBLKPUT returns a 1 if successful, 0
            otherwise.

            USAGE

            XMSBLKPUT places the pixel data contained in XMS memory
            referenced by srcxmshandle on the screen.  The top, left
            corner of the block is specified by (x, y).  Any (x, y) is
            acceptable and any portion of the block that lies outside of
            the currently defined viewport will not be drawn.  If the
            function was unsuccessful, check XMSERROR for error codes.

            All allocated XMS blocks must be freed using XMSFREE before a
            program terminates or the memory is lost until the machine is
            rebooted.  Simply exiting a program will not free allocated
            extended memory blocks.

            SEE ALSO

            BLKGET, BLKPUT, XMSBLKGET, XMSERROR, XMSFREE, XMSSCREENGET,
            XMSSCREENPUT

            EXAMPLE

            See XMSBLKGET
















                                                                        197







          XMSCOPY

            PROTOTYPE

            extern int far xmscopy (int xmssrchandle, long srcoffset, int
            xmsdesthandle, long destoffset, unsigned long count)

            INPUT

            xmssrchandle - handle of source extended memory block
            srcoffset - number of bytes from beginning of source memory
            block
            xmsdesthandle - handle of destination extended memory block
            destoffset - number of bytes from beginning of destination
            memory block
            count - number of bytes to copy from source to destination
            (must be even)

            OUTPUT

            XMSCOPY returns a 1 if copy was successful, 0 otherwise.

            USAGE

            XMSCOPY copies the number of bytes specified in count from the
            source extended memory block to the destination extended
            memory block.  Count must be an even number.  The copy may
            begin and/or end offset from the beginning of the source and
            destination blocks by passing non zero values in srcoffset
            and/or destoffset.  The copy will occur faster if both offsets
            are divisible by four.  If the copy was unsuccessful, check
            XMSERROR for error codes.

            SEE ALSO

            WHICHXMS, XMSALLOCATE, XMSERROR, XMSFREE, XMSGET, XMSPUT

            EXAMPLE

            /*
             * show xms functions: this will copy one array into one
             * xms block, copy that xms block to a second xms block,
             * and then copy that second xms block to another array
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"

            void main(void)
            {
               int i, handle1, handle2, er, mem, handles;
               int test1[10], test2[10];



                                                                        198







               /* make sure xms is ready and available */
               if ( whichxms(&mem,&handles) ) {
                 if ((mem < 1) || (handles < 1)) {
                    printf("sorry...there is either no free xms or\n");
                    printf("no free handles\n");
                    exit(1);
                 }
               }
               else {
                 printf("sorry...no active xms memory manager
            found...\n");
                 printf("make sure you have an xms memory manager\n");
                 printf("(such as HIMEM.SYS) loaded\n");
                 exit(1);
               }

               /* generate some data */
               for(i=0;i<10;i++)
               {
                 test1[i] = i;
               }

               /* allocate the first xms block */
               handle1 = xmsallocate(1);
               if ( !handle1 ) {
                 printf("opps there is some error...unable to allocate
            xms...\n");
                 printf("error # %d\n",xmserror());
                 er = xmsfree(handle1);
                 exit(1);
               }

               /* allocate the second xms block */
               handle2 = xmsallocate(1);
               if ( !handle2 ) {
                 printf("opps there is some error...unable to allocate
            xms...\n");
                 printf("error # %d\n",xmserror());
                 er = xmsfree(handle1);
                 er = xmsfree(handle2);
                 exit(1);
               }

               /* copy our source array into first xms block */
               er = xmsput (test1, handle1, 0, sizeof(test1));
               if ( !er ) {
                 printf("opps there is some error...see error code
            list...\n");
                 printf("error # %d\n",xmserror());
                 er = xmsfree(handle1);
                 er = xmsfree(handle2);
                 exit(1);
               }



                                                                        199







               /* copy first xms block into second xms block */
               er = xmscopy (handle1, 0, handle2, 0, sizeof(test1));
               if ( !er ) {
                 printf("opps there is some error...see error code
            list...\n");
                 printf("error # %d\n",xmserror());
                 er = xmsfree(handle1);
                 er = xmsfree(handle2);
                 exit(1);
               }

               /* copy second xms block to out destination array */
               er = xmsget (handle2, 0, test2, sizeof(test1));
               if ( !er ) {
                 printf("opps there is some error...see error code
            list...\n");
                 printf("error # %d\n",xmserror());
                 er = xmsfree(handle1);
                 er = xmsfree(handle2);
                 exit(1);
               }

               /* free up all the xms memory we have allocated */
               er = xmsfree(handle1);
               er = xmsfree(handle2);

               /* show the results */
               printf("ok...we initialized one array with data, copied
            that\n");
               printf("array to an xms block, copied that xms block to
            a\n");
               printf("second xms block, and finally copied the second
            xms\n");
               printf("block into a new array...here are the results:\n");
               printf(" \n");
               printf("source array         destination array\n");
               for(i=0;i<10;i++)
               {
               printf(" %d                    %d\n",test1[i],test2[i]);
               }
               exit(0);
            }














                                                                        200







          XMSERROR

            PROTOTYPE

            extern int far xmserror (void)

            INPUT

            no input parameters

            OUTPUT

            XMSERROR returns the error code from the most recent XMS
            function call.

            USAGE

            XMSERROR returns the error code from the most recent XMS
            function call.  Each XMS function resets the error code to
            zero.  Therefore, if there has been an error, the error code
            should be checked immediately.  The error code will be one of
            the following:

            0    no error
            1    WHICHXMS has not been
                 called
            2    number of bytes to
                 copy is zero
            3    number of bytes to
                 copy is odd
            4    offset into XMS block
                 is zero
            128  Function not
                 implemented
            129  VDISK device driver
                 was detected
            142  General driver error
            143  Unrecoverable driver
                 error
            146  DX is less than
                 /HMAMIN= parameter
            160  All extended memory is
                 allocated
            161  XMM handles are
                 exhausted
            162  Handle is invalid
            163  Source handle is
                 invalid
            164  Source offset is
                 invalid
            165  Destination handle is
                 invalid
            166  Destination offset is
                 invalid


                                                                        201







            167  Length is invalid
            168  Overlap in move
                 request is invalid
            169  Parity error detected
            171  Block locked

            SEE ALSO

            WHICHXMS, XMSALLOCATE, XMSBLKGET, XMSBLKPUT, XMSCOPY, XMSFREE,
            XMSGET, XMSPUT, XMSSCREENGET, XMSSCREENPUT

            EXAMPLE

            See XMSCOPY










































                                                                        202







          XMSFREE

            PROTOTYPE

            extern int far xmsfree (int xmshandle)

            INPUT

            xmshandle - handle of extended memory block to free

            OUTPUT

            XMSFREE returns 1 if extended memory block was deallocated, 0
            otherwise.

            USAGE

            XMSFREE deallocates the specified extended memory block.  All
            allocated blocks must be freed before a program terminates or
            the memory is lost until the machine is rebooted.  Simply
            exiting a program will not free allocated extended memory
            blocks.  If the function was unsuccessful, check XMSERROR for
            error codes.

            SEE ALSO

            WHICHXMS, XMSALLOCATE, XMSBLKGET, XMSBLKPUT, XMSCOPY,
            XMSERROR, XMSGET, XMSPUT, XMSSCREENGET, XMSSCREENPUT

            EXAMPLE

            See XMSCOPY
























                                                                        203







          XMSGET

            PROTOTYPE

            extern int far xmsget (int xmshandle, long offset, void far
            *destmem, unsigned long count)

            INPUT

            xmshandle - handle of source extended memory block
            offset - number of bytes from beginning of source memory block
            count - number of bytes to copy from extended memory to
            conventional memory (must be even)

            OUTPUT

            XMSGET returns 1 if the copy was successful, 0 otherwise.
            destmem - copy of data in conventional memory

            USAGE

            XMSGET retrieves data from extended memory and places it in
            conventional memory.  The number of bytes copied must be an
            even number and cannot be larger than 65536.  The copy may
            begin off the beginning of the source extended memory block by
            specifying an non zero offset.  If the function was
            unsuccessful, check XMSERROR for error codes.

            SEE ALSO

            WHICHXMS, XMSALLOCATE, XMSCOPY, XMSERROR, XMSFREE, XMSPUT

            EXAMPLE

            See XMSCOPY





















                                                                        204







          XMSPUT

            PROTOTYPE

            extern int far xmsput (void far *sourcemem, int xmshandle,
            long offset, unsigned long count)

            INPUT

            sourcemem - source data in conventional memory
            xmshandle - handle of destination extended memory block
            offset - number of bytes from beginning of destination memory
            block
            count - number of bytes to copy from conventional memory to
            extended memory (must be even)

            OUTPUT

            XMSPUT returns 1 if the copy was successful, 0 otherwise.

            USAGE

            XMSPUT copies data from conventional memory to extended
            memory.  The number of bytes copied must be an even number and
            cannot be larger than 65536.  The destination may begin off
            the beginning of the extended memory block by specifying an
            non zero offset.  If the function was unsuccessful, check
            XMSERROR for error codes.

            SEE ALSO

            WHICHXMS, XMSALLOCATE, XMSCOPY, XMSERROR, XMSFREE, XMSGET

            EXAMPLE

            See XMSCOPY




















                                                                        205







          XMSSCREENGET

            PROTOTYPE

            extern int far xmsscreenget ()

            INPUT

            no input parameters

            OUTPUT

            Used as a function, XMSSCREENGET returns the assigned XMS
            memory handle if successful, 0 otherwise.

            USAGE

            XMSSCREENGET stores the pixel data contained within the entire
            active screen.  The bitmap is stored such that the first
            integer in the allocated XMS block is the width and the second
            integer is the height.  These are followed by a long integer
            (4 bytes) specifying the total size of the allocated XMS
            block.  The remaining bytes are the bitmap raster data stored
            by rows starting at the top of the screen.  Note that this
            function is about twice as fast as using XMSBLKGET to save the
            entire screen.  If the function was unsuccessful, check
            XMSERROR for error codes.

            All allocated XMS blocks must be freed using XMSFREE before a
            program terminates or the memory is lost until the machine is
            rebooted.  Simply exiting a program will not free allocated
            extended memory blocks.

            SEE ALSO

            BLKGET, BLKPUT, XMSBLKGET, XMSBLKPUT, XMSERROR, XMSFREE,
            XMSSCREENPUT

            EXAMPLE

            /*
             * this will copy the whole sreen to xms and the redraw it
            from xms
             */

            #include <stdlib.h>
            #include <conio.h>
            #include "svgacc.h"
            #define randnum(size) (rand() % (int)(size))

            void main(void)
            {
               int i, handle, er, mem, handles,x1,y1,x2,y2,colr;
               char text[]="press a key...";


                                                                        206








               /* make sure xms is ready and available */
               if ( whichxms(&mem,&handles) ) {
                 if ((mem < 1) || (handles < 1)) {
                    printf("sorry...there is either no free xms or\n");
                    printf("no free handles\n");
                    exit(1);
                 }
               }
               else {
                 printf("sorry...no active xms memory manager
            found...\n");
                 printf("make sure you have an xms memory manager\n");
                 printf("(such as HIMEM.SYS) loaded\n");
                 exit(1);
               }

               if ( !whichvga() )
                 exit(1);
               if ( !res640() )
                 exit(1);
               fillscreen(10);
               for(i=0;i<=500;i++)
               {
                 x1 = randnum(maxx);
                 y1 = randnum(maxy);
                 x2 = randnum(maxx);
                 y2 = randnum(maxy);
                 colr = randnum(16);
                 drwline(1,colr,x1,y1,x2,y2);
               }
               drwbox(SET,15,0,0,maxx,maxy);
               handle = xmsscreenget();
               if ( !handle ) {
                 printf("opps there is some error...unable to allocate
            xms...\n");
                 printf("error # %d\n",xmserror());
                 er = xmsfree(handle);
                 exit(1);
               }
               drwstring(SET,10,0,text,0,0);
               getch();
               fillscreen(0);
               drwstring(SET,10,0,text,0,0);
               getch();
               er = xmsscreenput(handle);
               er = xmsfree(handle);

               getch();
               restext();
               exit(0);
            }




                                                                        207







          XMSSCREENPUT

            PROTOTYPE

            extern int far xmsblkput (int srcxmshandle)

            INPUT

            srcxmshandle - handle of source extended memory block

            OUTPUT

            Used as a function, XMSSCREENPUT returns a 1 if successful, 0
            otherwise.

            USAGE

            XMSSCREENPUT places the complete screen pixel data contained
            in xms memory referenced by srcxmshandle on the screen.  The
            current screen resolution must be the same as the saved screen
            resolution. this function is not bound by the current
            viewport.  If the function was unsuccessful, check XMSERROR
            for error codes.

            SEE ALSO

            BLKGET, BLKPUT, XMSBLKGET, XMSBLKPUT, XMSERROR, XMSFREE,
            XMSSCREENGET

            EXAMPLE

            See XMSSCREENGET
























                                                                        208







          APPENDIX A.  SVGACC.H

          This is the header file containing function prototypes and
          structure definitions for SVGACC.LIB.  This file should be
          included in every program module that uses this library.  To
          properly include the header file, place the following line at the
          top of the every code module:

                                 #include "svgacc.h"

          Without these prototypes and definitions, the C/C++ compiler will
          be unable to compile any code module using the commands found in
          this library.

          /* SVGACC Include File for Microsoft compatible C/C++ compilers
           * Copyright 1993-2000 by Stephen L. Balkum and Daniel A. Sill
           * Zephyr Software P.O. Box 407, Pflugerville, Texas  78691-0407
           * Last Update 1/1/95
           */

          #ifndef SVGACC_H
          #define SVGACC_H

          typedef unsigned char byte;

          typedef struct {
            char r;
            char g;
            char b;
          } RGB;

          typedef RGB PaletteData[256];

          typedef struct {
            byte hotspotx;
            byte hotspoty;
            byte data[384];
          } MouseCursor;

          typedef struct {
            byte width;
            byte height;
            byte data[4096];
          } Font;

          typedef enum {
            NO_ACTION = 0,
            SET,
            XOR,
            OR,
            AND
          } PixelMode;

          typedef enum {


                                                                        209







            UNKNOWN = 0,
            ACUMOS,
            ATI,
            AHEADA,
            AHEADB,
            CHIPSTECH,
            CIRRUS,
            EVEREX,
            GENOA,
            NCR,
            OAKTECH,
            PARADISE,
            REALTEK,
            TRIDENT,
            TSENG3,
            TSENG4,
            VESA,
            VIDEO7,
            AVANCE,
            MXIC,
            PRIMUS
          } VGAChipset;

          typedef struct {
            unsigned int width;
            unsigned int height;
            byte data[1];
          } RasterBlock;

          typedef struct {
            int x;
            int y;
          } D2Point;

          typedef struct {
            int x;
            int y;
            int z;
          } D3Point;

          typedef struct {
            int eyex;
            int eyey;
            int eyez;
            int scrd;
            int theta;
            int phi;
          } ProjParameters;

          #ifdef __cplusplus
          extern "C" {
          #endif

          /* Global variables */


                                                                        210







          extern const int far maxx;
          extern const int far maxy;
          extern const int far viewx1;
          extern const int far viewy1;
          extern const int far viewx2;
          extern const int far viewy2;

          /* 'BLocK' methods to manipulate RasterBlocks on and off the
          screen */

          extern int  far blkget (int x1, int y1, int x2, int y2,
          RasterBlock far *gfxblk);
          extern void far blkput (PixelMode mode, int x, int y, RasterBlock
          far *gfxblk);
          extern void far blkresize (unsigned newxsize, unsigned newysize,
          RasterBlock far *sourcegfxblk, RasterBlock far *destgfxblk);
          extern int  far blkrotate (int ang, int backfill, RasterBlock far
          *sourcegfxblk, RasterBlock far *destgfxblk);
          extern int  far blkrotatesize (int ang, RasterBlock far
          *sourcegfxblk);

          /* 'BYTECOPY' method for fast memory copy */

          extern void far bytecopy (void far *src, void far *dst, unsigned
          long numbytes);

          /* '2D' methods to transform D2Points */

          extern void far d2rotate (int points, int xorigin, int yorigin,
          int ang, D2Point far *inary, D2Point far *outary);
          extern void far d2scale (int points, int xscale, int yscale,
          D2Point far *inary, D2Point far *outary);
          extern void far d2translate (int points, int xtrans, int ytrans,
          D2Point far *inary, D2Point far *outary);

          /* '3D' methods to transform D3Points */

          extern int  far d3project (int points, ProjParameters far
          *params, D3Point far *inary, D2Point far *outary);
          extern void far d3rotate (int points, int xorigin, int yorigin,
          int zorigin, int zrang, int yrang, int xrang, D3Point far *inary,
          D3Point far *outary);
          extern void far d3scale (int points, int xscale, int yscale, int
          zscale, D3Point far *inary, D3Point far *outary);
          extern void far d3translate (int points, int xtrans, int ytrans,
          int ztrans, D3Point far *inary, D3Point far *outary);

          /* 'DRaW' methods for placing text and graphics primitives on
          screen */

          extern void far drwaline (int colrbits, int colr, int x1, int y1,
          int x2, int y2);
          extern void far drwbox (PixelMode mode, int colr, int x1, int y1,
          int x2, int y2);


                                                                        211







          extern void far drwcirarc (PixelMode mode, int colr, int centerx,
          int centery, int radius, long startang, long endang);
          extern void far drwcircle (PixelMode mode, int colr, int centerx,
          int centery, int radius);
          extern void far drwcubicbezier (PixelMode mode, int colr, D2Point
          far *pon1, D2Point far *poff1, D2Point far *poff2, D2Point far
          *pon2);
          extern void far drwellarc (PixelMode mode, int colr, int centerx,
          int centery, int radiusx, int radiusy, long startang, long
          endang);
          extern void far drwellipse (PixelMode mode, int colr, int
          centerx, int centery, int radiusx, int radiusy);
          extern void far drwfillbox (PixelMode mode, int colr, int x1, int
          y1, int x2, int y2);
          extern void far drwfillcircle (PixelMode mode, int colr, int
          centerx, int centery, int radius);
          extern void far drwfillellipse (PixelMode mode, int colr, int
          centerx, int centery, int radiusx, int radiusy);
          extern void far drwline (PixelMode mode, int colr, int x1, int
          y1, int x2, int y2);
          extern void far drwpoint (PixelMode mode, int colr, int x, int
          y);
          extern void far drwstring (PixelMode mode, int fcolr, int bcolr,
          const char far *strng, int x, int y);
          extern void far drwstringdn (PixelMode mode, int fcolr, int
          bcolr, const char far *strng, int x, int y);
          extern void far drwstringlt (PixelMode mode, int fcolr, int
          bcolr, const char far *strng, int x, int y);
          extern void far drwstringrt (PixelMode mode, int fcolr, int
          bcolr, const char far *strng, int x, int y);

          /* 'FILL' methods for filling various regions on screen with a
          color */

          extern void far fillarea (int xseed, int yseed, int bordercolr,
          int fillcolr);
          extern void far fillconvexpoly (int colr, int points, D2Point far
          *inary);
          extern void far fillpoly (int colr, int points, D2Point far
          *inary);
          extern void far fillcolor (int xseed, int yseed, int oldcolr, int
          newcolr);
          extern void far fillpage (int colr);
          extern void far fillscreen (int colr);
          extern void far fillview (int colr);

          /* 'FONT' methods for setting the current font */

          extern void far fontgetinfo (int far *wdth, int far *hght);
          extern void far fontset (Font far *font);
          extern void far fontsystem (void);

          /* 'GET' methods to return information held by library */



                                                                        212







          extern void far getlaststring (RasterBlock far *strnggfxblk);
          extern long far getarccos (long cosvalue);
          extern long far getarcsin (long sinvalue);
          extern long far getarctan (long tanvalue);
          extern long far getcos (long angle);
          extern int  far getpoint (int x, int y);
          extern long far getsin (long angle);
          extern long far gettan (long angle);

          /* 'JOYSTICK' method to read joysticks' status */

          extern void far joystickinfo (int far *jax, int far *jay, int far
          *jabuts, int far *jbx, int far *jby, int far *jbbuts);

          /* 'MOUSE' methods to interact with mouse driver */

          extern void far mousebutpress (int reqbut, int far *xloc, int far
          *yloc, int far *num, int far *mbuts);
          extern void far mousebutrelease (int reqbut, int far *xloc, int
          far *yloc, int far *num, int far *mbuts);
          extern void far mousecursordefault (void);
          extern void far mousecursorset (MouseCursor far *mousecursor);
          extern void far mouseenter (void);
          extern void far mouseexit (void);
          extern void far mousehide (void);
          extern void far mouseinfo (int far *drvmajorver, int far
          *drvminorver, int far *mousetype, int far *irqnumber);
          extern void far mouselocset (int xloc, int yloc);
          extern void far mouserangeset (int x1, int y1, int x2, int y2);
          extern void far mouserestorestate (byte far *mousebuf);
          extern void far mousesavestate (byte far *mousebuf);
          extern void far mousesensset (int xsens, int ysens, int
          dblspdthresh);
          extern void far mouseshow (void);
          extern void far mousestatus (int far *x, int far *y, int far
          *mbuts);
          extern int  far mousestoragesize (void);

          extern void far overscanset (int colr);

          /* 'PAGE' methods to control paging abilities */

          extern int  far pageactive (int page);
          extern int  far pagedisplay (int x, int y, int page);

          /* 'PALette' methods to manipulate and activate palettes */

          extern void far palchgauto (RGB far *pal, RGB far *newpal, int
          firstcolr, int lastcolr, int speed);
          extern void far palchgstep (RGB far *pal, RGB far *newpal, int
          firstcolr, int lastcolr, int percent);
          extern void far palcopy (RGB far *srcpal, RGB far *destpal, int
          firstcolr, int lastcolr);



                                                                        213







          extern void far paldimstep (RGB far *pal, int firstcolr, int
          lastcolr, int percent);
          extern void far palget (RGB far *pal, int firstcolr, int
          lastcolr);
          extern void far palioauto (RGB far *pal, int firstcolr, int
          lastcolr, int speed);
          extern void far palrotate (RGB far *pal, int firstcolr, int
          lastcolr, int shift);
          extern void far palset (RGB far *pal, int firstcolr, int
          lastcolr);

          /* 'PCX' methods to read / write PCX files and place images on
          screen */

          extern int  far pcxgetinfo (const char far *name, int far
          *pcxxsize, int far *pcxysize, int far *numcolors, RGB far *pal);
          extern int  far pcxmake (int x1, int y1, int x2, int y2, const
          char far *name);
          extern int  far pcxput (PixelMode mode, int xloc, int yloc, const
          char far *name);

          /* 'RESolution' methods to set various video modes */

          extern int  far res320 (void);
          extern int  far res640 (void);
          extern int  far res640l (void);
          extern int  far res800 (void);
          extern int  far res1024 (void);
          extern int  far res1280 (void);
          extern int  far restext (void);

          /* 'SCROLL' methods for scrolling various sections of the screen
          */

          extern void far scrolldn (int x1, int y1, int x2, int y2, int
          num, int colr);
          extern void far scrolllt (int x1, int y1, int x2, int y2, int
          num, int colr);
          extern void far scrollrt (int x1, int y1, int x2, int y2, int
          num, int colr);
          extern void far scrollup (int x1, int y1, int x2, int y2, int
          num, int colr);

          /* 'Sync' DELAY method */

          extern void far sdelay (int count);

          /* 'SET' methods to adjust library internal variables */

          extern void far setcard (VGAChipset chip, int mem);
          extern void far setview (int x1, int y1, int x2, int y2);

          /* 'SPRITE' methods for manipulating sprites on and off screen */



                                                                        214







          extern int  far spritecolldetect (int transcolr, int x1, int y1,
          int x2, int y2, RasterBlock far *sprite1, RasterBlock far
          *sprite2);
          extern void far spritegap (int transcolr, int x, int y,
          RasterBlock far *sprite, RasterBlock far *spritebkgnd);
          extern void far spriteget (int transcolr, int x, int y,
          RasterBlock far *sprite, RasterBlock far *spritebkgnd);
          extern void far spriteput (PixelMode mode, int transcolr, int x,
          int y, RasterBlock far *sprite);

          /* 'VIDEO' methods to interact with video mode and display */

          extern int  far videomodeget (void);
          extern void far videomodeset (int videomode);
          extern void far videooff (void);
          extern void far videoon (void);

          /* 'Identification' methods to discover WHICH hardware is
          available */

          extern int  far whichcpu (void);
          extern int  far whichjoystick (void);
          extern int  far whichmem (void);
          extern int  far whichmouse (void);
          extern VGAChipset far whichvga (void);
          extern int  far whichxms (unsigned int far *xmskbytesavail,
          unsigned int far *xmshandlesavail);

          /* 'XMS' methods to store and retrieve extended memory */

          extern int  far xmsallocate (unsigned int reqkbytes);
          extern int  far xmsblkget (int x1, int y1, int x2, int y2);
          extern int  far xmsblkput (PixelMode mode, int x, int y, int
          xmshandle);
          extern int  far xmscopy (int xmssrchandle, long srcoffset, int
          xmsdesthandle, long destoffset, unsigned long count);
          extern int  far xmserror (void);
          extern int  far xmsfree (int xmshandle);
          extern int  far xmsget (int xmshandle, long offset, void far
          *destmem, unsigned long count);
          extern int  far xmsput (void far *sourcemem, int xmshandle, long
          offset, unsigned long count);
          extern int  far xmsscreenget (void);
          extern int  far xmsscreenput (int xmshandle);

          #ifdef __cplusplus
          }
          #endif

          #endif
          /* SVGACC_H */





                                                                        215







          APPENDIX B.  JOYSTICK PORTS AND Y-CABLES

          SCHEMATIC WIRING DIAGRAM FOR A STANDARD JOYSTICK PORT

                                    DB15 male
                                    connector
                   Joystick B            ___       Joystick A
                                      __/   |
                                     /    o | 1 -------------------+
             +------------------  9 | o     |     ___Button A      |
             |     Button A___      |     o | 2 --o o-+            |
             |           +-o o-- 10 | o     |         |    X Axis  |
             |  X Axis   |          |     o | 3 -------------+     |
             |     +------------ 11 | o     |         |      |     |
             |     |     |          |     o | 4 ------+      |     |
             +--/\/\/\   +------ 12 | o     |         |    /\/\/\--+
             |           |          |     o | 5       |            |
             |     +------------ 13 | o     |         |            |
             |     |     | ___      |     o | 6 -------------+     |
             |     |     +-o o-- 14 | o     |     ___ |      |     |
             |     |    Button B    |     o | 7 --o o-+      |     |
             |     |             15 | o     |   Button B   /\/\/\--+
             +--/\/\/\               \__  o | 8            Y Axis
               Y Axis                   \___|

          Notes:

          1)This diagram comes with NO warranties expressed or implied.
            It is provided for information only.  In no event shall
            Stephen L. Balkum, Daniel A. Sill or Zephyr Software be held
            liable for damages resulting from use, misuse, or inability to
            use this information.

          2)The x and y axis potentiometers have a typical range of 0 to
            100k ohms.  Buttons are normally open and close when pressed.

          3)This diagram is correct for joystick ports that conform to the
            standard set forth by IBM. Some specialty joystick cards
            provide separate A and B joystick connectors.  For these
            cards, both connectors are wired to pins 1 through 8 as shown
            in the diagram.

          4)Many 'Super I/O' boards (2H/2F/2S/1P/1G) equipped with a
            joystick port will support only one joystick.  On these cards,
            pins 9 through 15 are not used.

          5)Commercially available joysticks are wired to use pins 1
            through 8 and, therefore, will always be 'Joystick A' if
            plugged directly into a dual joystick port connector.

          6)Many sound cards provide joystick ports; however, their
            connector wiring does not always conform to the standard shown
            above.  Some of these connectors may be used for other



                                                                        216







            purposes such as a MIDI port.  See the documentation that
            comes with the sound card.

          7)If there is more than one joystick port on a computer
            configured to operate the same joystick, only ONE port should
            be enabled at any given time for proper operation.  Disable
            all but one joystick port.  For example, if the computer has
            both a Super I/O card and a sound card, the joystick port on
            the Super I/O card should be disabled since the sound card's
            port probably supports two joysticks and the I/O card supports
            only one.













































                                                                        217







          SCHEMATIC WIRING DIAGRAM FOR A JOYSTICK Y-CABLE

                                             ___
                         DB15 male         __/   |
                       connector to       /    o | 1 --------+
                       Joystick Port   9 | o     |           |
                        on computer      |     o | 2 --------|-+
                            +-------- 10 | o     |           | |
                            |            |     o | 3 --------|-|-+
                            | +------ 11 | o     |           | | |
                            | |          |     o | 4 --------|-|-|-+
                            | |       12 | o     |           | | | |
                            | |          |     o | 5         | | | |
                            | | +---- 13 | o     |           | | | |
                            | | |        |     o | 6 --------|-|-|-|-+
                            | | | +-- 14 | o     |           | | | | |
                            | | | |      |     o | 7 --------|-|-|-|-|-+
                            | | | |   15 | o     |           | | | | | |
                            | | | |       \__  o | 8         | | | | | |
                            | | | |          \___|           | | | | | |
                            | | | |                          | | | | | |
                            | | | |                          | | | | | |
                            | | | |  +-----------------------+ | | | | |
                            | | | |  |                       | | | | | |
                            | | | |  | +---------------------|-|-|-+ | |
                            | | | |  | |                     | | | | | |
                            | | | |  | |                     | | | | | |
           DB15 female      | | | |  | |     DB15 female     | | | | | |
           connector to     | | | |  | |     connector to    | | | | | |
            Joystick B      | | | |  | |      Joystick A     | | | | | |
                  ___       | | | |  | |            ___      | | | | | |
               __/   |      | | | |  | |         __/   |     | | | | | |
              /    o | 1 ---|-|-|-|--+ |        /    o | 1 --+ | | | | |
           9 | o     |      | | | |    |     9 | o     |       | | | | |
             |     o | 2 ---+ | | |    |       |     o | 2 ----+ | | | |
          10 | o     |        | | |    |    10 | o     |         | | | |
             |     o | 3 -----+ | |    |       |     o | 3 ------+ | | |
          11 | o     |          | |    |    11 | o     |           | | |
             |     o | 4 -------|-|----+       |     o | 4 --------+ | |
          12 | o     |          | |         12 | o     |             | |
             |     o | 5        | |            |     o | 5           | |
          13 | o     |          | |         13 | o     |             | |
             |     o | 6 -------+ |            |     o | 6 ----------+ |
          14 | o     |            |         14 | o     |               |
             |     o | 7 ---------+            |     o | 7 ------------+
          15 | o     |                      15 | o     |
              \__  o | 8                        \__  o | 8
                 \___|                             \___|

          Notes:

          1)This diagram comes with NO warranties expressed or implied.
            It is provided for information only.  In no event shall
            Stephen L. Balkum, Daniel A. Sill or Zephyr Software be held


                                                                        218







            liable for damages resulting from use, misuse, or inability to
            use this information.

          2)This cable has worked with a standard joystick port connector,
            a Sound Blaster port connector, and a Sound Blaster Pro
            joystick port connector.


















































                                                                        219

